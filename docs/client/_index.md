---
title: "CLI tools"
weight: 06
type: "docs"
showlandingtoc: "false"
aliases:
  - /docs/reference/resources
---

The following CLI tools are available for use with Knative, either for installation, resource creation and modification, or development purposes, as explained in the description for each tool.

## kubectl CLI

You can use the `kubectl` CLI to apply the YAML files required to install Knative components, and also to create Knative resources, such as services and event sources using YAML.

### Next steps

- <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" target="_blank">Install the `kubectl` CLI</a>

## kn CLI

The `kn` CLI cannot be used to install Knative components, but provides a quick and easy interface for creating Knative resources such as services and event sources, without the need to create or modify YAML files directly. The `kn` CLI also simplifies completion of otherwise complex procedures such as autoscaling and traffic splitting.

### Next steps

- [Install the `kn` CLI](./install-kn/)
- [Connect the `kn` CLI to your cluster](./install-kn#connecting-the-kn-cli-to-your-cluster)

## ko CLI

The <a href="https://github.com/google/ko" target="_blank">`ko` CLI</a> is designed to simplify the development of Go apps on Kubernetes by
abstracting away the container image being used, and instead referring to Go
packages by their <a href="https://golang.org/doc/code.html#ImportPaths" target="_blank">import paths</a>, for example `github.com/kaniko/serving/cmd/controller`.

`ko` is used in the development and release of Knative components, but is not
intended to be a requirement for end users. Users are only required to `kubectl apply` the released configuration files generated by `ko`.

Example of typical `ko` usage:
```
ko apply --filename config.yaml
```

This command reads the configuration YAML, and looks for Go import paths representing runnable commands, for example, `package main`.

When a matching import path is found, `ko` builds the package
using `go build`, and then pushes a container image containing that binary on top of a base image. By default, this image pushes `gcr.io/distroless/base` to
`$KO_DOCKER_REPO/unique-string`.
After pushing those images, `ko` replaces instances of matched import paths with fully-qualified references to the images it pushed.

For example, if `ko apply` was passed the following configuration:
```
---
image: github.com/my/repo/cmd/foo
```
The following YAML would be produced:
```
---
image: gcr.io/my-docker-repo/foo-zyxwvut@sha256:abcdef # image by digest
```
This example assumes that you have set the environment variable
`KO_DOCKER_REPO=gcr.io/my-docker-repo`.

`ko apply` then passes the generated YAML configuration to `kubectl apply`.

`ko` also supports the following tasks:

- `ko publish` to simply push images and not produce configs.
- `ko resolve` to push images and output the generated configs, but not
  `kubectl apply` them.
- `ko delete` to simply passthrough to `kubectl delete` for convenience.
