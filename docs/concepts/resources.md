---
title: "Resources"
weight: 10
type: "docs"
---

This page contains information about various tools and technologies that are
useful to anyone developing on Knative.

### [`ko`](https://github.com/google/ko)

`ko` is a tool designed to make development of Go apps on Kubernetes easier, by
abstracting away the container image being used, and instead referring to Go
packages by their [import paths](https://golang.org/doc/code.html#ImportPaths)
(e.g., `github.com/kaniko/serving/cmd/controller`)

The typical usage is `ko apply --filename config.yaml`, which reads in the
config YAML, and looks for Go import paths representing runnable commands (i.e.,
`package main`). When it finds a matching import path, `ko` builds the package
using `go build` then pushes a container image containing that binary on top of
a base image (by default, `gcr.io/distroless/base`) to
`$KO_DOCKER_REPO/unique-string`. After pushing those images, `ko` replaces
instances of matched import paths with fully-qualified references to the images
it pushed.

So if `ko apply` was passed this config:

```yaml
---
image: github.com/my/repo/cmd/foo
```

...it would produce YAML like:

```yaml
---
image: gcr.io/my-docker-repo/foo-zyxwvut@sha256:abcdef # image by digest
```

(This assumes that you have set the environment variable
`KO_DOCKER_REPO=gcr.io/my-docker-repo`)

`ko apply` then passes this generated YAML config to `kubectl apply`.

`ko` also supports:

- `ko publish` to simply push images and not produce configs.
- `ko resolve` to push images and output the generated configs, but not
  `kubectl apply` them.
- `ko delete` to simply passthrough to `kubectl delete` for convenience.

`ko` is used during development and release of Knative components, but is not
intended to be required for _users_ of Knative -- they should only need to
`kubectl apply` released configs generated by `ko`.
