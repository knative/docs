<p>Packages:</p>
<ul>
<li>
<a href="#duck.knative.dev%2fv1beta1">duck.knative.dev/v1beta1</a>
</li>
<li>
<a href="#autoscaling.internal.knative.dev%2fv1alpha1">autoscaling.internal.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#serving.knative.dev%2fv1">serving.knative.dev/v1</a>
</li>
<li>
<a href="#serving.knative.dev%2fv1alpha1">serving.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#duck.knative.dev%2fv1">duck.knative.dev/v1</a>
</li>
<li>
<a href="#networking.internal.knative.dev%2fv1alpha1">networking.internal.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#serving.knative.dev%2fv1beta1">serving.knative.dev/v1beta1</a>
</li>
<li>
<a href="#eventing.knative.dev%2fv1alpha1">eventing.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#flows.knative.dev%2fv1alpha1">flows.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#messaging.knative.dev%2fv1beta1">messaging.knative.dev/v1beta1</a>
</li>
<li>
<a href="#sources.knative.dev%2fv1alpha2">sources.knative.dev/v1alpha2</a>
</li>
<li>
<a href="#configs.internal.knative.dev%2fv1alpha1">configs.internal.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#duck.knative.dev%2fv1alpha1">duck.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#eventing.knative.dev%2fv1beta1">eventing.knative.dev/v1beta1</a>
</li>
<li>
<a href="#flows.knative.dev%2fv1beta1">flows.knative.dev/v1beta1</a>
</li>
<li>
<a href="#camel.apache.org%2fv1">camel.apache.org/v1</a>
</li>
<li>
<a href="#sources.knative.dev%2fv1alpha1">sources.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#bindings.knative.dev%2fv1alpha1">bindings.knative.dev/v1alpha1</a>
</li>
<li>
<a href="#messaging.knative.dev%2fv1alpha1">messaging.knative.dev/v1alpha1</a>
</li>
</ul>
<h2 id="duck.knative.dev/v1beta1">duck.knative.dev/v1beta1</h2>
<p>
<p>Package v1beta1 is the v1beta1 version of the API.</p>
</p>
Resource Types:
<ul></ul>
<h3 id="duck.knative.dev/v1beta1.AddressStatus">AddressStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.AddressableType">AddressableType</a>)
</p>
<p>
<p>AddressStatus shows how we expect folks to embed Addressable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Addressable">
Addressable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Addressable">Addressable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.AddressStatus">AddressStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.Addressable">Addressable</a>)
</p>
<p>
<p>Addressable provides a generic mechanism for a custom resource
definition to indicate a destination for message delivery.</p>
<p>Addressable is the schema for the destination information. This is
typically stored in the object&rsquo;s <code>status</code>, as this information may
be generated by the controller.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.AddressableType">AddressableType
</h3>
<p>
<p>AddressableType is a skeleton type wrapping Addressable in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Addressable ObjectReferences and
access the Addressable data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.BackoffPolicyType">BackoffPolicyType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">DeliverySpec</a>)
</p>
<p>
<p>BackoffPolicyType is the type for backoff policies</p>
</p>
<h3 id="duck.knative.dev/v1beta1.Channelable">Channelable
</h3>
<p>
<p>Channelable is a skeleton type wrapping Subscribable and Addressable in the manner we expect resource writers
defining compatible resources to embed it. We will typically use this type to deserialize
Channelable ObjectReferences and access their subscription and address data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>Spec is the part where the Channelable fulfills the Subscribable contract.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>SubscribableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">
SubscribableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">
ChannelableStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.ChannelableSpec">ChannelableSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.ChannelSpec">ChannelSpec</a>, 
<a href="#duck.knative.dev/v1beta1.Channelable">Channelable</a>, 
<a href="#messaging.knative.dev/v1beta1.InMemoryChannelSpec">InMemoryChannelSpec</a>)
</p>
<p>
<p>ChannelableSpec contains Spec of the Channelable object</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SubscribableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">
SubscribableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.ChannelableStatus">ChannelableStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.ChannelStatus">ChannelStatus</a>, 
<a href="#duck.knative.dev/v1beta1.Channelable">Channelable</a>, 
<a href="#messaging.knative.dev/v1beta1.InMemoryChannelStatus">InMemoryChannelStatus</a>)
</p>
<p>
<p>ChannelableStatus contains the Status of a Channelable object.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the part where the Channelable fulfills the Addressable contract.</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableStatus</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableStatus">
SubscribableStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
<tr>
<td>
<code>deadLetterChannel</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel
Failed messages are delivered here.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.CloudEventOverrides">CloudEventOverrides
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.SourceSpec">SourceSpec</a>)
</p>
<p>
<p>CloudEventOverrides defines arguments for a Source that control the output
format of the CloudEvents produced by the Source.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensions</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Extensions specify what attribute are added or overridden on the
outbound event. Each <code>Extensions</code> key-value pair are set on the event as
an attribute extension independently.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Conditions">Conditions
(<code>[]knative.dev/pkg/apis.Condition</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.Status">Status</a>)
</p>
<p>
<p>Conditions is a simple wrapper around apis.Conditions to implement duck.Implementable.</p>
</p>
<h3 id="duck.knative.dev/v1beta1.DeliverySpec">DeliverySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.BrokerSpec">BrokerSpec</a>, 
<a href="#eventing.knative.dev/v1beta1.BrokerSpec">BrokerSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.ChannelSpec">ChannelSpec</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedSpec">ChannelableCombinedSpec</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">ChannelableSpec</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableSpec">ChannelableSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelSpec">InMemoryChannelSpec</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelBranch">ParallelBranch</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelBranch">ParallelBranch</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceStep">SequenceStep</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceStep">SequenceStep</a>, 
<a href="#duck.knative.dev/v1alpha1.SubscriberSpec">SubscriberSpec</a>, 
<a href="#duck.knative.dev/v1beta1.SubscriberSpec">SubscriberSpec</a>, 
<a href="#messaging.knative.dev/v1beta1.SubscriptionSpec">SubscriptionSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.SubscriptionSpec">SubscriptionSpec</a>)
</p>
<p>
<p>DeliverySpec contains the delivery options for event senders,
such as channelable and source.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>deadLetterSink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeadLetterSink is the sink receiving event that could not be sent to
a destination.</p>
</td>
</tr>
<tr>
<td>
<code>retry</code></br>
<em>
int32
</em>
</td>
<td>
<em>(Optional)</em>
<p>Retry is the minimum number of retries the sender should attempt when
sending an event before moving it to the dead letter sink.</p>
</td>
</tr>
<tr>
<td>
<code>backoffPolicy</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.BackoffPolicyType">
BackoffPolicyType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackoffPolicy is the retry backoff policy (linear, exponential).</p>
</td>
</tr>
<tr>
<td>
<code>backoffDelay</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackoffDelay is the delay before retrying.
More information on Duration format: <a href="https://www.ietf.org/rfc/rfc3339.txt">https://www.ietf.org/rfc/rfc3339.txt</a></p>
<p>For linear policy, backoff delay is the time interval between retries.
For exponential policy , backoff delay is backoffDelay*2^<numberOfRetries>.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.DeliveryStatus">DeliveryStatus
</h3>
<p>
<p>DeliveryStatus contains the Status of an object supporting delivery options.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>deadLetterChannel</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeadLetterChannel is a KReference that is the reference to the native, platform specific channel
where failed events are sent to.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Destination">Destination
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceSpec">ApiServerSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.CamelSourceSpec">CamelSourceSpec</a>, 
<a href="#duck.knative.dev/v1beta1.SourceSpec">SourceSpec</a>)
</p>
<p>
<p>Destination represents a target of an invocation over HTTP.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ref</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Ref points to an Addressable.</p>
</td>
</tr>
<tr>
<td>
<code>apiVersion</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>namespace</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>uri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.KResource">KResource
</h3>
<p>
<p>KResource is a skeleton type wrapping Conditions in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Conditions ObjectReferences and
access the Conditions data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Status">
Status
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Source">Source
</h3>
<p>
<p>Source is the minimum resource shape to adhere to the Source Specification.
This duck type is intended to allow implementors of Sources and
Importers to verify their own resources meet the expectations.
This is not a real resource.
NOTE: The Source Specification is in progress and the shape and names could
be modified until it has been accepted.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a domain name or a
URI directly to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SourceSpec">SourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.Source">Source</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a domain name or a
URI directly to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SourceStatus">SourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.Source">Source</a>)
</p>
<p>
<p>SourceStatus shows how we expect folks to embed Addressable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1beta1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.</p>
</td>
</tr>
<tr>
<td>
<code>sinkUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>SinkURI is the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Status">Status
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.KResource">KResource</a>, 
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelStatus">KafkaChannelStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.NatssChannelStatus">NatssChannelStatus</a>, 
<a href="#duck.knative.dev/v1beta1.SourceStatus">SourceStatus</a>)
</p>
<p>
<p>Status shows how we expect folks to embed Conditions in
their Status field.
WARNING: Adding fields to this struct will add them to all Knative resources.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>observedGeneration</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ObservedGeneration is the &lsquo;Generation&rsquo; of the Service that
was last processed by the controller.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Conditions">
Conditions
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Conditions the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.Subscribable">Subscribable
</h3>
<p>
<p>Subscribable is a skeleton type wrapping Subscribable in the manner we expect resource writers
defining compatible resources to embed it. We will typically use this type to deserialize
SubscribableType ObjectReferences and access the Subscription data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">
SubscribableSpec
</a>
</em>
</td>
<td>
<p>SubscribableSpec is the part where Subscribable object is
configured as to be compatible with Subscribable contract.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>subscribers</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscriberSpec">
[]SubscriberSpec
</a>
</em>
</td>
<td>
<p>This is the list of subscriptions for this subscribable.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableStatus">
SubscribableStatus
</a>
</em>
</td>
<td>
<p>SubscribableStatus is the part where SubscribableStatus object is
configured as to be compatible with Subscribable contract.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SubscribableSpec">SubscribableSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedSpec">ChannelableCombinedSpec</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">ChannelableSpec</a>, 
<a href="#duck.knative.dev/v1beta1.Subscribable">Subscribable</a>)
</p>
<p>
<p>SubscribableSpec shows how we expect folks to embed Subscribable in their Spec field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribers</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscriberSpec">
[]SubscriberSpec
</a>
</em>
</td>
<td>
<p>This is the list of subscriptions for this subscribable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SubscribableStatus">SubscribableStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedStatus">ChannelableCombinedStatus</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#duck.knative.dev/v1beta1.Subscribable">Subscribable</a>)
</p>
<p>
<p>SubscribableStatus is the schema for the subscribable&rsquo;s status portion of the status
section of the resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribers</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscriberStatus">
[]SubscriberStatus
</a>
</em>
</td>
<td>
<p>This is the list of subscription&rsquo;s statuses for this channel.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SubscriberSpec">SubscriberSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">SubscribableSpec</a>)
</p>
<p>
<p>SubscriberSpec defines a single subscriber to a Subscribable.</p>
<p>At least one of SubscriberURI and ReplyURI must be present</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>uid</code></br>
<em>
k8s.io/apimachinery/pkg/types.UID
</em>
</td>
<td>
<em>(Optional)</em>
<p>UID is used to understand the origin of the subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Generation of the origin of the subscriber with uid:UID.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>SubscriberURI is the endpoint for the subscriber</p>
</td>
</tr>
<tr>
<td>
<code>replyUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>ReplyURI is the endpoint for the reply</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1beta1.SubscriberStatus">SubscriberStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1beta1.SubscribableStatus">SubscribableStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.SubscribableStatus">SubscribableStatus</a>)
</p>
<p>
<p>SubscriberStatus defines the status of a single subscriber to a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>uid</code></br>
<em>
k8s.io/apimachinery/pkg/types.UID
</em>
</td>
<td>
<em>(Optional)</em>
<p>UID is used to understand the origin of the subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>observedGeneration</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Generation of the origin of the subscriber with uid:UID.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#conditionstatus-v1-core">
Kubernetes core/v1.ConditionStatus
</a>
</em>
</td>
<td>
<p>Status of the subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>message</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>A human readable message indicating details of Ready status.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="autoscaling.internal.knative.dev/v1alpha1">autoscaling.internal.knative.dev/v1alpha1</h2>
<p>
</p>
Resource Types:
<ul><li>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscaler">PodAutoscaler</a>
</li></ul>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodAutoscaler">PodAutoscaler
</h3>
<p>
<p>PodAutoscaler is a Knative abstraction that encapsulates the interface by which Knative
components instantiate autoscalers.  This definition is an abstraction that may be backed
by multiple definitions.  For more information, see the Knative Pluggability presentation:
<a href="https://docs.google.com/presentation/d/10KWynvAJYuOEWy69VBa6bHJVCqIsz1TNdEKosNvcpPY/edit">https://docs.google.com/presentation/d/10KWynvAJYuOEWy69VBa6bHJVCqIsz1TNdEKosNvcpPY/edit</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
autoscaling.internal.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>PodAutoscaler</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerSpec">
PodAutoscalerSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the PodAutoscaler (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed
in-flight (concurrent) requests per container of the Revision.
Defaults to <code>0</code> which means unlimited concurrency.</p>
</td>
</tr>
<tr>
<td>
<code>scaleTargetRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
is responsible for quickly right-sizing.</p>
</td>
</tr>
<tr>
<td>
<code>reachability</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.ReachabilityType">
ReachabilityType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reachable specifies whether or not the <code>ScaleTargetRef</code> can be reached (ie. has a route).
Defaults to <code>ReachabilityUnknown</code></p>
</td>
</tr>
<tr>
<td>
<code>protocolType</code></br>
<em>
knative.dev/serving/pkg/apis/networking.ProtocolType
</em>
</td>
<td>
<p>The application-layer protocol. Matches <code>ProtocolType</code> inferred from the revision spec.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerStatus">
PodAutoscalerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the PodAutoscaler (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.Metric">Metric
</h3>
<p>
<p>Metric represents a resource to configure the metric collector with.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.MetricSpec">
MetricSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Metric (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>stableWindow</code></br>
<em>
time.Duration
</em>
</td>
<td>
<p>StableWindow is the aggregation window for metrics in a stable state.</p>
</td>
</tr>
<tr>
<td>
<code>panicWindow</code></br>
<em>
time.Duration
</em>
</td>
<td>
<p>PanicWindow is the aggregation window for metrics where quick reactions are needed.</p>
</td>
</tr>
<tr>
<td>
<code>scrapeTarget</code></br>
<em>
string
</em>
</td>
<td>
<p>ScrapeTarget is the K8s service that publishes the metric endpoint.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.MetricStatus">
MetricStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Metric (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.MetricSpec">MetricSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.Metric">Metric</a>)
</p>
<p>
<p>MetricSpec contains all values a metric collector needs to operate.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>stableWindow</code></br>
<em>
time.Duration
</em>
</td>
<td>
<p>StableWindow is the aggregation window for metrics in a stable state.</p>
</td>
</tr>
<tr>
<td>
<code>panicWindow</code></br>
<em>
time.Duration
</em>
</td>
<td>
<p>PanicWindow is the aggregation window for metrics where quick reactions are needed.</p>
</td>
</tr>
<tr>
<td>
<code>scrapeTarget</code></br>
<em>
string
</em>
</td>
<td>
<p>ScrapeTarget is the K8s service that publishes the metric endpoint.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.MetricStatus">MetricStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.Metric">Metric</a>)
</p>
<p>
<p>MetricStatus reflects the status of metric collection for this specific entity.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerSpec">PodAutoscalerSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscaler">PodAutoscaler</a>)
</p>
<p>
<p>PodAutoscalerSpec holds the desired state of the PodAutoscaler (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed
in-flight (concurrent) requests per container of the Revision.
Defaults to <code>0</code> which means unlimited concurrency.</p>
</td>
</tr>
<tr>
<td>
<code>scaleTargetRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
is responsible for quickly right-sizing.</p>
</td>
</tr>
<tr>
<td>
<code>reachability</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.ReachabilityType">
ReachabilityType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reachable specifies whether or not the <code>ScaleTargetRef</code> can be reached (ie. has a route).
Defaults to <code>ReachabilityUnknown</code></p>
</td>
</tr>
<tr>
<td>
<code>protocolType</code></br>
<em>
knative.dev/serving/pkg/apis/networking.ProtocolType
</em>
</td>
<td>
<p>The application-layer protocol. Matches <code>ProtocolType</code> inferred from the revision spec.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerStatus">PodAutoscalerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscaler">PodAutoscaler</a>)
</p>
<p>
<p>PodAutoscalerStatus communicates the observed state of the PodAutoscaler (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceName is the K8s Service name that serves the revision, scaled by this PA.
The service is created and owned by the ServerlessService object owned by this PA.</p>
</td>
</tr>
<tr>
<td>
<code>metricsServiceName</code></br>
<em>
string
</em>
</td>
<td>
<p>MetricsServiceName is the K8s Service name that provides revision metrics.
The service is managed by the PA object.</p>
</td>
</tr>
<tr>
<td>
<code>desiredScale</code></br>
<em>
int32
</em>
</td>
<td>
<p>DesiredScale shows the current desired number of replicas for the revision.</p>
</td>
</tr>
<tr>
<td>
<code>actualScale</code></br>
<em>
int32
</em>
</td>
<td>
<p>ActualScale shows the actual number of replicas for the revision.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodScalable">PodScalable
</h3>
<p>
<p>PodScalable is a duck type that the resources referenced by the
PodAutoscaler&rsquo;s ScaleTargetRef must implement.  They must also
implement the <code>/scale</code> sub-resource for use with <code>/scale</code> based
implementations (e.g. HPA), but this further constrains the shape
the referenced resources may take.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodScalableSpec">
PodScalableSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podtemplatespec-v1-core">
Kubernetes core/v1.PodTemplateSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodScalableStatus">
PodScalableStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodScalableSpec">PodScalableSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodScalable">PodScalable</a>)
</p>
<p>
<p>PodScalableSpec is the specification for the desired state of a
PodScalable (or at least our shared portion).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podtemplatespec-v1-core">
Kubernetes core/v1.PodTemplateSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.PodScalableStatus">PodScalableStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodScalable">PodScalable</a>)
</p>
<p>
<p>PodScalableStatus is the observed state of a PodScalable (or at
least our shared portion).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="autoscaling.internal.knative.dev/v1alpha1.ReachabilityType">ReachabilityType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerSpec">PodAutoscalerSpec</a>)
</p>
<p>
<p>ReachabilityType is the enumeration type for the different states of reachability
to the <code>ScaleTarget</code> of a <code>PodAutoscaler</code></p>
</p>
<hr/>
<h2 id="serving.knative.dev/v1">serving.knative.dev/v1</h2>
<p>
</p>
Resource Types:
<ul><li>
<a href="#serving.knative.dev/v1.Configuration">Configuration</a>
</li><li>
<a href="#serving.knative.dev/v1.Revision">Revision</a>
</li><li>
<a href="#serving.knative.dev/v1.Route">Route</a>
</li><li>
<a href="#serving.knative.dev/v1.Service">Service</a>
</li></ul>
<h3 id="serving.knative.dev/v1.Configuration">Configuration
</h3>
<p>
<p>Configuration represents the &ldquo;floating HEAD&rdquo; of a linear history of Revisions.
Users create new Revisions by updating the Configuration&rsquo;s spec.
The &ldquo;latest created&rdquo; revision&rsquo;s name is available under status, as is the
&ldquo;latest ready&rdquo; revision&rsquo;s name.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration">https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Configuration</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Template holds the latest specification for the Revision to be stamped out.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationStatus">
ConfigurationStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.Revision">Revision
</h3>
<p>
<p>Revision is an immutable snapshot of code and configuration.  A revision
references a container image. Revisions are created by updates to a
Configuration.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision">https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Revision</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>PodSpec</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">
Kubernetes core/v1.PodSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>PodSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
requests per container of the Revision.  Defaults to <code>0</code> which means
concurrency to the application is not limited, and the system decides the
target concurrency for the autoscaler.</p>
</td>
</tr>
<tr>
<td>
<code>timeoutSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TimeoutSeconds holds the max duration the instance is allowed for
responding to a request.  If unspecified, a system default will
be provided.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionStatus">
RevisionStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.Route">Route
</h3>
<p>
<p>Route is responsible for configuring ingress over a collection of Revisions.
Some of the Revisions a Route distributes traffic over may be specified by
referencing the Configuration responsible for creating them; in these cases
the Route is additionally responsible for monitoring the Configuration for
&ldquo;latest ready revision&rdquo; changes, and smoothly rolling out latest revisions.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#route">https://github.com/knative/serving/blob/master/docs/spec/overview.md#route</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Route</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Route (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic specifies how to distribute traffic over a collection of
revisions and configurations.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Route (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.Service">Service
</h3>
<p>
<p>Service acts as a top-level container that manages a Route and Configuration
which implement a network service. Service exists to provide a singular
abstraction which can be access controlled, reasoned about, and which
encapsulates software lifecycle decisions such as rollout policy and
team resource ownership. Service acts only as an orchestrator of the
underlying Routes and Configurations (much as a kubernetes Deployment
orchestrates ReplicaSets), and its usage is optional but recommended.</p>
<p>The Service&rsquo;s controller will track the statuses of its owned Configuration
and Route, reflecting their statuses and conditions as its own.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#service">https://github.com/knative/serving/blob/master/docs/spec/overview.md#service</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Service</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.ServiceSpec">
ServiceSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>ConfigurationSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines an unrestricted ConfigurationSpec.</p>
</td>
</tr>
<tr>
<td>
<code>RouteSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines RouteSpec and restricts/defaults its fields
via webhook.  In particular, this spec can only reference this
Service&rsquo;s configuration and revisions (which also influences
defaults).</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.ServiceStatus">
ServiceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ConfigurationSpec">ConfigurationSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Configuration">Configuration</a>, 
<a href="#serving.knative.dev/v1beta1.Configuration">Configuration</a>, 
<a href="#serving.knative.dev/v1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>ConfigurationSpec holds the desired state of the Configuration (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Template holds the latest specification for the Revision to be stamped out.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ConfigurationStatus">ConfigurationStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Configuration">Configuration</a>, 
<a href="#serving.knative.dev/v1beta1.Configuration">Configuration</a>)
</p>
<p>
<p>ConfigurationStatus communicates the observed state of the Configuration (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationStatusFields">
ConfigurationStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ConfigurationStatusFields">ConfigurationStatusFields
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.ConfigurationStatus">ConfigurationStatus</a>, 
<a href="#serving.knative.dev/v1.ServiceStatus">ServiceStatus</a>)
</p>
<p>
<p>ConfigurationStatusFields holds the fields of Configuration&rsquo;s status that
are not generally shared.  This is defined separately and inlined so that
other types can readily consume these fields via duck typing.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>latestReadyRevisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LatestReadyRevisionName holds the name of the latest Revision stamped out
from this Configuration that has had its &ldquo;Ready&rdquo; condition become &ldquo;True&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>latestCreatedRevisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LatestCreatedRevisionName is the last revision that was created from this
Configuration. It might not be ready yet, for that use LatestReadyRevisionName.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ContainerStatuses">ContainerStatuses
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.RevisionStatus">RevisionStatus</a>)
</p>
<p>
<p>ContainerStatuses holds the information of container name and image digest value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>imageDigest</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RevisionSpec">RevisionSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Revision">Revision</a>, 
<a href="#serving.knative.dev/v1beta1.Revision">Revision</a>, 
<a href="#serving.knative.dev/v1alpha1.RevisionSpec">RevisionSpec</a>, 
<a href="#serving.knative.dev/v1.RevisionTemplateSpec">RevisionTemplateSpec</a>)
</p>
<p>
<p>RevisionSpec holds the desired state of the Revision (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>PodSpec</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">
Kubernetes core/v1.PodSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>PodSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
requests per container of the Revision.  Defaults to <code>0</code> which means
concurrency to the application is not limited, and the system decides the
target concurrency for the autoscaler.</p>
</td>
</tr>
<tr>
<td>
<code>timeoutSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TimeoutSeconds holds the max duration the instance is allowed for
responding to a request.  If unspecified, a system default will
be provided.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RevisionStatus">RevisionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Revision">Revision</a>, 
<a href="#serving.knative.dev/v1beta1.Revision">Revision</a>)
</p>
<p>
<p>RevisionStatus communicates the observed state of the Revision (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName holds the name of a core Kubernetes Service resource that
load balances over the pods backing this Revision.</p>
</td>
</tr>
<tr>
<td>
<code>logUrl</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LogURL specifies the generated logging url for this particular revision
based on the revision url template specified in the controller&rsquo;s config.</p>
</td>
</tr>
<tr>
<td>
<code>imageDigest</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedImageDigest holds the resolved digest for the image specified
within .Spec.Container.Image. The digest is resolved during the creation
of Revision. This field holds the digest value regardless of whether
a tag or digest was originally specified in the Container object. It
may be empty if the image comes from a registry listed to skip resolution.
If multiple containers specified then DeprecatedImageDigest holds the digest
for serving container.
DEPRECATED: Use ContainerStatuses instead.
TODO(savitaashture) Remove deprecatedImageDigest.
ref <a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy">https://kubernetes.io/docs/reference/using-api/deprecation-policy</a> for deprecation.</p>
</td>
</tr>
<tr>
<td>
<code>containerStatuses</code></br>
<em>
<a href="#serving.knative.dev/v1.ContainerStatuses">
[]ContainerStatuses
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerStatuses is a slice of images present in .Spec.Container[*].Image
to their respective digests and their container name.
The digests are resolved during the creation of Revision.
ContainerStatuses holds the container name and image digests
for both serving and non serving containers.
ref: <a href="http://bit.ly/image-digests">http://bit.ly/image-digests</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RevisionTemplateSpec">RevisionTemplateSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">ConfigurationSpec</a>)
</p>
<p>
<p>RevisionTemplateSpec describes the data a revision should have when created from a template.
Based on: <a href="https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190">https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>PodSpec</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">
Kubernetes core/v1.PodSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>PodSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
requests per container of the Revision.  Defaults to <code>0</code> which means
concurrency to the application is not limited, and the system decides the
target concurrency for the autoscaler.</p>
</td>
</tr>
<tr>
<td>
<code>timeoutSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TimeoutSeconds holds the max duration the instance is allowed for
responding to a request.  If unspecified, a system default will
be provided.</p>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RouteSpec">RouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Route">Route</a>, 
<a href="#serving.knative.dev/v1beta1.Route">Route</a>, 
<a href="#serving.knative.dev/v1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>RouteSpec holds the desired state of the Route (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic specifies how to distribute traffic over a collection of
revisions and configurations.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RouteStatus">RouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.Route">Route</a>, 
<a href="#serving.knative.dev/v1beta1.Route">Route</a>)
</p>
<p>
<p>RouteStatus communicates the observed state of the Route (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>RouteStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteStatusFields">
RouteStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.RouteStatusFields">RouteStatusFields
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.RouteStatus">RouteStatus</a>, 
<a href="#serving.knative.dev/v1.ServiceStatus">ServiceStatus</a>)
</p>
<p>
<p>RouteStatusFields holds the fields of Route&rsquo;s status that
are not generally shared.  This is defined separately and inlined so that
other types can readily consume these fields via duck typing.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>URL holds the url that will distribute traffic over the provided traffic targets.
It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}</p>
</td>
</tr>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1.Addressable">
Addressable
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Address holds the information needed for a Route to be the target of an event.</p>
</td>
</tr>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic holds the configured traffic distribution.
These entries will always contain RevisionName references.
When ConfigurationName appears in the spec, this will hold the
LatestReadyRevisionName that we last observed.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ServiceSpec">ServiceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1beta1.Service">Service</a>, 
<a href="#serving.knative.dev/v1.Service">Service</a>)
</p>
<p>
<p>ServiceSpec represents the configuration for the Service object.
A Service&rsquo;s specification is the union of the specifications for a Route
and Configuration.  The Service restricts what can be expressed in these
fields, e.g. the Route must reference the provided Configuration;
however, these limitations also enable friendlier defaulting,
e.g. Route never needs a Configuration name, and may be defaulted to
the appropriate &ldquo;run latest&rdquo; spec.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ConfigurationSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines an unrestricted ConfigurationSpec.</p>
</td>
</tr>
<tr>
<td>
<code>RouteSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines RouteSpec and restricts/defaults its fields
via webhook.  In particular, this spec can only reference this
Service&rsquo;s configuration and revisions (which also influences
defaults).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.ServiceStatus">ServiceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1beta1.Service">Service</a>, 
<a href="#serving.knative.dev/v1.Service">Service</a>)
</p>
<p>
<p>ServiceStatus represents the Status stanza of the Service resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationStatusFields">
ConfigurationStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationStatusFields</code> are embedded into this type.)
</p>
<p>In addition to inlining ConfigurationSpec, we also inline the fields
specific to ConfigurationStatus.</p>
</td>
</tr>
<tr>
<td>
<code>RouteStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteStatusFields">
RouteStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatusFields</code> are embedded into this type.)
</p>
<p>In addition to inlining RouteSpec, we also inline the fields
specific to RouteStatus.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1.TrafficTarget">TrafficTarget
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1.RouteSpec">RouteSpec</a>, 
<a href="#serving.knative.dev/v1.RouteStatusFields">RouteStatusFields</a>, 
<a href="#serving.knative.dev/v1alpha1.TrafficTarget">TrafficTarget</a>)
</p>
<p>
<p>TrafficTarget holds a single entry of the routing table for a Route.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>tag</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Tag is optionally used to expose a dedicated url for referencing
this target exclusively.</p>
</td>
</tr>
<tr>
<td>
<code>revisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>RevisionName of a specific revision to which to send this portion of
traffic.  This is mutually exclusive with ConfigurationName.</p>
</td>
</tr>
<tr>
<td>
<code>configurationName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ConfigurationName of a configuration to whose latest revision we will send
this portion of traffic. When the &ldquo;status.latestReadyRevisionName&rdquo; of the
referenced configuration changes, we will automatically migrate traffic
from the prior &ldquo;latest ready&rdquo; revision to the new one.  This field is never
set in Route&rsquo;s status, only its spec.  This is mutually exclusive with
RevisionName.</p>
</td>
</tr>
<tr>
<td>
<code>latestRevision</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>LatestRevision may be optionally provided to indicate that the latest
ready Revision of the Configuration should be used for this traffic
target.  When provided LatestRevision must be true if RevisionName is
empty; it must be false when RevisionName is non-empty.</p>
</td>
</tr>
<tr>
<td>
<code>percent</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Percent indicates that percentage based routing should be used and
the value indicates the percent of traffic that is be routed to this
Revision or Configuration. <code>0</code> (zero) mean no traffic, <code>100</code> means all
traffic.
When percentage based routing is being used the follow rules apply:
- the sum of all percent values must equal 100
- when not specified, the implied value for <code>percent</code> is zero for
that particular Revision or Configuration</p>
</td>
</tr>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>URL displays the URL for accessing named traffic targets. URL is displayed in
status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="serving.knative.dev/v1alpha1">serving.knative.dev/v1alpha1</h2>
<p>
</p>
Resource Types:
<ul><li>
<a href="#serving.knative.dev/v1alpha1.Configuration">Configuration</a>
</li><li>
<a href="#serving.knative.dev/v1alpha1.Revision">Revision</a>
</li><li>
<a href="#serving.knative.dev/v1alpha1.Route">Route</a>
</li><li>
<a href="#serving.knative.dev/v1alpha1.Service">Service</a>
</li></ul>
<h3 id="serving.knative.dev/v1alpha1.Configuration">Configuration
</h3>
<p>
<p>Configuration represents the &ldquo;floating HEAD&rdquo; of a linear history of Revisions,
and optionally how the containers those revisions reference are built.
Users create new Revisions by updating the Configuration&rsquo;s spec.
The &ldquo;latest created&rdquo; revision&rsquo;s name is available under status, as is the
&ldquo;latest ready&rdquo; revision&rsquo;s name.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration">https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Configuration</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Configuration (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>build</code></br>
<em>
k8s.io/apimachinery/pkg/runtime.RawExtension
</em>
</td>
<td>
<em>(Optional)</em>
<p>Build optionally holds the specification for the build to
perform to produce the Revision&rsquo;s container image.</p>
</td>
</tr>
<tr>
<td>
<code>revisionTemplate</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedRevisionTemplate holds the latest specification for the Revision to
be stamped out. If a Build specification is provided, then the
DeprecatedRevisionTemplate&rsquo;s BuildName field will be populated with the name of
the Build object created to produce the container for the Revision.
DEPRECATED Use Template instead.</p>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Template holds the latest specification for the Revision to
be stamped out.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationStatus">
ConfigurationStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Configuration (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.Revision">Revision
</h3>
<p>
<p>Revision is an immutable snapshot of code and configuration.  A revision
references a container image, and optionally a build that is responsible for
materializing that container image from source. Revisions are created by
updates to a Configuration.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision">https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Revision</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Revision (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>RevisionSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RevisionSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>servingState</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.DeprecatedRevisionServingStateType">
DeprecatedRevisionServingStateType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedServingState holds a value describing the desired state the Kubernetes
resources should be in for this Revision.
Users must not specify this when creating a revision. These values are no longer
updated by the system.</p>
</td>
</tr>
<tr>
<td>
<code>container</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core">
Kubernetes core/v1.Container
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedContainer defines the unit of execution for this Revision.
In the context of a Revision, we disallow a number of the fields of
this Container, including: name and lifecycle.
See also the runtime contract for more information about the execution
environment:
<a href="https://github.com/knative/serving/blob/master/docs/runtime-contract.md">https://github.com/knative/serving/blob/master/docs/runtime-contract.md</a></p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionStatus">
RevisionStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Revision (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.Route">Route
</h3>
<p>
<p>Route is responsible for configuring ingress over a collection of Revisions.
Some of the Revisions a Route distributes traffic over may be specified by
referencing the Configuration responsible for creating them; in these cases
the Route is additionally responsible for monitoring the Configuration for
&ldquo;latest ready&rdquo; revision changes, and smoothly rolling out latest revisions.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#route">https://github.com/knative/serving/blob/master/docs/spec/overview.md#route</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Route</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Route (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic specifies how to distribute traffic over a collection of Knative Serving Revisions and Configurations.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Route (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.Service">Service
</h3>
<p>
<p>Service acts as a top-level container that manages a set of Routes and
Configurations which implement a network service. Service exists to provide a
singular abstraction which can be access controlled, reasoned about, and
which encapsulates software lifecycle decisions such as rollout policy and
team resource ownership. Service acts only as an orchestrator of the
underlying Routes and Configurations (much as a kubernetes Deployment
orchestrates ReplicaSets), and its usage is optional but recommended.</p>
<p>The Service&rsquo;s controller will track the statuses of its owned Configuration
and Route, reflecting their statuses and conditions as its own.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#service">https://github.com/knative/serving/blob/master/docs/spec/overview.md#service</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Service</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">
ServiceSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>runLatest</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RunLatestType">
RunLatestType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedRunLatest defines a simple Service. It will automatically
configure a route that keeps the latest ready revision
from the supplied configuration running.</p>
</td>
</tr>
<tr>
<td>
<code>pinned</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.PinnedType">
PinnedType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedPinned is DEPRECATED in favor of ReleaseType</p>
</td>
</tr>
<tr>
<td>
<code>manual</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ManualType">
ManualType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedManual mode enables users to start managing the underlying Route and Configuration
resources directly.  This advanced usage is intended as a path for users to graduate
from the limited capabilities of Service to the full power of Route.</p>
</td>
</tr>
<tr>
<td>
<code>release</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ReleaseType">
ReleaseType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Release enables gradual promotion of new revisions by allowing traffic
to be split between two revisions. This type replaces the deprecated Pinned type.</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationSpec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationSpec</code> are embedded into this type.)
</p>
<p>We are moving to a shape where the Configuration and Route specifications
are inlined into the Service, which gives them compatible shapes.  We are
staging this change here as a path to this in v1beta1, which drops the
&ldquo;mode&rdquo; based specifications above.  Ultimately all non-v1beta1 fields will
be deprecated, and then dropped in v1beta1.</p>
</td>
</tr>
<tr>
<td>
<code>RouteSpec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ServiceStatus">
ServiceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.CannotConvertError">CannotConvertError
</h3>
<p>
<p>CannotConvertError is returned when a field cannot be converted.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Message</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>Field</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ConfigurationSpec">ConfigurationSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Configuration">Configuration</a>, 
<a href="#serving.knative.dev/v1alpha1.PinnedType">PinnedType</a>, 
<a href="#serving.knative.dev/v1alpha1.ReleaseType">ReleaseType</a>, 
<a href="#serving.knative.dev/v1alpha1.RunLatestType">RunLatestType</a>, 
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>ConfigurationSpec holds the desired state of the Configuration (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>build</code></br>
<em>
k8s.io/apimachinery/pkg/runtime.RawExtension
</em>
</td>
<td>
<em>(Optional)</em>
<p>Build optionally holds the specification for the build to
perform to produce the Revision&rsquo;s container image.</p>
</td>
</tr>
<tr>
<td>
<code>revisionTemplate</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedRevisionTemplate holds the latest specification for the Revision to
be stamped out. If a Build specification is provided, then the
DeprecatedRevisionTemplate&rsquo;s BuildName field will be populated with the name of
the Build object created to produce the container for the Revision.
DEPRECATED Use Template instead.</p>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Template holds the latest specification for the Revision to
be stamped out.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ConfigurationStatus">ConfigurationStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Configuration">Configuration</a>)
</p>
<p>
<p>ConfigurationStatus communicates the observed state of the Configuration (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationStatusFields">
ConfigurationStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ConfigurationStatusFields">ConfigurationStatusFields
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationStatus">ConfigurationStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.ServiceStatus">ServiceStatus</a>)
</p>
<p>
<p>ConfigurationStatusFields holds all of the non-duckv1.Status status fields of a Route.
These are defined outline so that we can also inline them into Service, and more easily
copy them.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>latestReadyRevisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LatestReadyRevisionName holds the name of the latest Revision stamped out
from this Configuration that has had its &ldquo;Ready&rdquo; condition become &ldquo;True&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>latestCreatedRevisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LatestCreatedRevisionName is the last revision that was created from this
Configuration. It might not be ready yet, for that use LatestReadyRevisionName.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ContainerStatuses">ContainerStatuses
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.RevisionStatus">RevisionStatus</a>)
</p>
<p>
<p>ContainerStatuses holds the information of container name and image digest value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>imageDigest</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.DeprecatedRevisionServingStateType">DeprecatedRevisionServingStateType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.RevisionSpec">RevisionSpec</a>)
</p>
<p>
<p>DeprecatedRevisionServingStateType is an enumeration of the levels of serving readiness of the Revision.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting">https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting</a></p>
</p>
<h3 id="serving.knative.dev/v1alpha1.ManualType">ManualType
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>ManualType contains the options for configuring a manual service. See ServiceSpec for
more details.</p>
</p>
<h3 id="serving.knative.dev/v1alpha1.PinnedType">PinnedType
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>PinnedType is DEPRECATED. ReleaseType should be used instead. To get the behavior of PinnedType set
ReleaseType.Revisions to []string{PinnedType.RevisionName} and ReleaseType.RolloutPercent to 0.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>revisionName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The revision name to pin this service to until changed
to a different service type.</p>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>The configuration for this service.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ReleaseType">ReleaseType
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>ReleaseType contains the options for slowly releasing revisions. See ServiceSpec for
more details.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>revisions</code></br>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Revisions is an ordered list of 1 or 2 revisions. The first will
have a TrafficTarget with a name of &ldquo;current&rdquo; and the second will have
a name of &ldquo;candidate&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>rolloutPercent</code></br>
<em>
int
</em>
</td>
<td>
<em>(Optional)</em>
<p>RolloutPercent is the percent of traffic that should be sent to the &ldquo;candidate&rdquo;
revision. Valid values are between 0 and 99 inclusive.</p>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>The configuration for this service. All revisions from this service must
come from a single configuration.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RevisionSpec">RevisionSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Revision">Revision</a>, 
<a href="#serving.knative.dev/v1alpha1.RevisionTemplateSpec">RevisionTemplateSpec</a>)
</p>
<p>
<p>RevisionSpec holds the desired state of the Revision (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RevisionSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RevisionSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>servingState</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.DeprecatedRevisionServingStateType">
DeprecatedRevisionServingStateType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedServingState holds a value describing the desired state the Kubernetes
resources should be in for this Revision.
Users must not specify this when creating a revision. These values are no longer
updated by the system.</p>
</td>
</tr>
<tr>
<td>
<code>container</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core">
Kubernetes core/v1.Container
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedContainer defines the unit of execution for this Revision.
In the context of a Revision, we disallow a number of the fields of
this Container, including: name and lifecycle.
See also the runtime contract for more information about the execution
environment:
<a href="https://github.com/knative/serving/blob/master/docs/runtime-contract.md">https://github.com/knative/serving/blob/master/docs/runtime-contract.md</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RevisionStatus">RevisionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Revision">Revision</a>)
</p>
<p>
<p>RevisionStatus communicates the observed state of the Revision (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName holds the name of a core Kubernetes Service resource that
load balances over the pods backing this Revision.</p>
</td>
</tr>
<tr>
<td>
<code>logUrl</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>LogURL specifies the generated logging url for this particular revision
based on the revision url template specified in the controller&rsquo;s config.</p>
</td>
</tr>
<tr>
<td>
<code>imageDigest</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedImageDigest holds the resolved digest for the image specified
within .Spec.Container.Image. The digest is resolved during the creation
of Revision. This field holds the digest value regardless of whether
a tag or digest was originally specified in the Container object. It
may be empty if the image comes from a registry listed to skip resolution.
If multiple containers specified then DeprecatedImageDigest holds the digest
for serving container.
DEPRECATED: Use ContainerStatuses instead.
TODO(savitaashture) Remove deprecatedImageDigest.
ref <a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy">https://kubernetes.io/docs/reference/using-api/deprecation-policy</a> for deprecation.</p>
</td>
</tr>
<tr>
<td>
<code>containerStatuses</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ContainerStatuses">
[]ContainerStatuses
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerStatuses is a slice of images present in .Spec.Container[*].Image
to their respective digests and their container name.
The digests are resolved during the creation of Revision.
ContainerStatuses holds the container name and image digests
for both serving and non serving containers.
ref: <a href="http://bit.ly/image-digests">http://bit.ly/image-digests</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RevisionTemplateSpec">RevisionTemplateSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">ConfigurationSpec</a>)
</p>
<p>
<p>RevisionTemplateSpec describes the data a revision should have when created from a template.
Based on: <a href="https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190">https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>RevisionSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RevisionSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>servingState</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.DeprecatedRevisionServingStateType">
DeprecatedRevisionServingStateType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedServingState holds a value describing the desired state the Kubernetes
resources should be in for this Revision.
Users must not specify this when creating a revision. These values are no longer
updated by the system.</p>
</td>
</tr>
<tr>
<td>
<code>container</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core">
Kubernetes core/v1.Container
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedContainer defines the unit of execution for this Revision.
In the context of a Revision, we disallow a number of the fields of
this Container, including: name and lifecycle.
See also the runtime contract for more information about the execution
environment:
<a href="https://github.com/knative/serving/blob/master/docs/runtime-contract.md">https://github.com/knative/serving/blob/master/docs/runtime-contract.md</a></p>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RouteSpec">RouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Route">Route</a>, 
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>RouteSpec holds the desired state of the Route (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic specifies how to distribute traffic over a collection of Knative Serving Revisions and Configurations.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RouteStatus">RouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Route">Route</a>)
</p>
<p>
<p>RouteStatus communicates the observed state of the Route (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>RouteStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteStatusFields">
RouteStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RouteStatusFields">RouteStatusFields
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.RouteStatus">RouteStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.ServiceStatus">ServiceStatus</a>)
</p>
<p>
<p>RouteStatusFields holds all of the non-duckv1.Status status fields of a Route.
These are defined outline so that we can also inline them into Service, and more easily
copy them.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>URL holds the url that will distribute traffic over the provided traffic targets.
It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}</p>
</td>
</tr>
<tr>
<td>
<code>domain</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedDomain holds the top-level domain that will distribute traffic over the provided targets.
It generally has the form {route-name}.{route-namespace}.{cluster-level-suffix}</p>
</td>
</tr>
<tr>
<td>
<code>domainInternal</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedDomainInternal holds the top-level domain that will distribute traffic over the provided
targets from inside the cluster. It generally has the form
{route-name}.{route-namespace}.svc.{cluster-domain-name}
DEPRECATED: Use Address instead.</p>
</td>
</tr>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Addressable">
Addressable
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Address holds the information needed for a Route to be the target of an event.</p>
</td>
</tr>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic holds the configured traffic distribution.
These entries will always contain RevisionName references.
When ConfigurationName appears in the spec, this will hold the
LatestReadyRevisionName that we last observed.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.RunLatestType">RunLatestType
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec</a>)
</p>
<p>
<p>RunLatestType contains the options for always having a route to the latest configuration. See
ServiceSpec for more details.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>The configuration for this service.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ServiceSpec">ServiceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Service">Service</a>)
</p>
<p>
<p>ServiceSpec represents the configuration for the Service object. Exactly one
of its members (other than Generation) must be specified. Services can either
track the latest ready revision of a configuration or be pinned to a specific
revision.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>runLatest</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RunLatestType">
RunLatestType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedRunLatest defines a simple Service. It will automatically
configure a route that keeps the latest ready revision
from the supplied configuration running.</p>
</td>
</tr>
<tr>
<td>
<code>pinned</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.PinnedType">
PinnedType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedPinned is DEPRECATED in favor of ReleaseType</p>
</td>
</tr>
<tr>
<td>
<code>manual</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ManualType">
ManualType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedManual mode enables users to start managing the underlying Route and Configuration
resources directly.  This advanced usage is intended as a path for users to graduate
from the limited capabilities of Service to the full power of Route.</p>
</td>
</tr>
<tr>
<td>
<code>release</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ReleaseType">
ReleaseType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Release enables gradual promotion of new revisions by allowing traffic
to be split between two revisions. This type replaces the deprecated Pinned type.</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationSpec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationSpec</code> are embedded into this type.)
</p>
<p>We are moving to a shape where the Configuration and Route specifications
are inlined into the Service, which gives them compatible shapes.  We are
staging this change here as a path to this in v1beta1, which drops the
&ldquo;mode&rdquo; based specifications above.  Ultimately all non-v1beta1 fields will
be deprecated, and then dropped in v1beta1.</p>
</td>
</tr>
<tr>
<td>
<code>RouteSpec</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.ServiceStatus">ServiceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.Service">Service</a>)
</p>
<p>
<p>ServiceStatus represents the Status stanza of the Service resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>RouteStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.RouteStatusFields">
RouteStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>ConfigurationStatusFields</code></br>
<em>
<a href="#serving.knative.dev/v1alpha1.ConfigurationStatusFields">
ConfigurationStatusFields
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationStatusFields</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1alpha1.TrafficTarget">TrafficTarget
</h3>
<p>
(<em>Appears on:</em>
<a href="#serving.knative.dev/v1alpha1.RouteSpec">RouteSpec</a>, 
<a href="#serving.knative.dev/v1alpha1.RouteStatusFields">RouteStatusFields</a>)
</p>
<p>
<p>TrafficTarget holds a single entry of the routing table for a Route.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Name is optionally used to expose a dedicated hostname for referencing this
target exclusively. It has the form: {name}.${route.status.domain}</p>
</td>
</tr>
<tr>
<td>
<code>TrafficTarget</code></br>
<em>
<a href="#serving.knative.dev/v1.TrafficTarget">
TrafficTarget
</a>
</em>
</td>
<td>
<p>
(Members of <code>TrafficTarget</code> are embedded into this type.)
</p>
<p>We inherit most of our fields by inlining the v1 type.
Ultimately all non-v1 fields will be deprecated.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="duck.knative.dev/v1">duck.knative.dev/v1</h2>
<p>
</p>
Resource Types:
<ul></ul>
<h3 id="duck.knative.dev/v1.AddressStatus">AddressStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.AddressableType">AddressableType</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelStatus">ParallelStatus</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelStatus">ParallelStatus</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceStatus">SequenceStatus</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceStatus">SequenceStatus</a>)
</p>
<p>
<p>AddressStatus shows how we expect folks to embed Addressable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1.Addressable">
Addressable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.Addressable">Addressable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.AddressStatus">AddressStatus</a>, 
<a href="#eventing.knative.dev/v1beta1.BrokerStatus">BrokerStatus</a>, 
<a href="#serving.knative.dev/v1.RouteStatusFields">RouteStatusFields</a>)
</p>
<p>
<p>Addressable provides a generic mechanism for a custom resource
definition to indicate a destination for message delivery.</p>
<p>Addressable is the schema for the destination information. This is
typically stored in the object&rsquo;s <code>status</code>, as this information may
be generated by the controller.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.AddressableType">AddressableType
</h3>
<p>
<p>AddressableType is a skeleton type wrapping Addressable in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Addressable ObjectReferences and
access the Addressable data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.CloudEventAttributes">CloudEventAttributes
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.SourceStatus">SourceStatus</a>)
</p>
<p>
<p>CloudEventAttributes specifies the attributes that a Source
uses as part of its CloudEvents.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
<p>Type refers to the CloudEvent type attribute.</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
string
</em>
</td>
<td>
<p>Source is the CloudEvents source attribute.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.CloudEventOverrides">CloudEventOverrides
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceSpec">ApiServerSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.CamelSourceSpec">CamelSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.PingSourceSpec">PingSourceSpec</a>, 
<a href="#duck.knative.dev/v1.SourceSpec">SourceSpec</a>)
</p>
<p>
<p>CloudEventOverrides defines arguments for a Source that control the output
format of the CloudEvents produced by the Source.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensions</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Extensions specify what attribute are added or overridden on the
outbound event. Each <code>Extensions</code> key-value pair are set on the event as
an attribute extension independently.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.Conditions">Conditions
(<code>[]knative.dev/pkg/apis.Condition</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.Status">Status</a>)
</p>
<p>
<p>Conditions is a simple wrapper around apis.Conditions to implement duck.Implementable.</p>
</p>
<h3 id="duck.knative.dev/v1.Destination">Destination
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSourceSpec">CouchDbSourceSpec</a>, 
<a href="#duck.knative.dev/v1beta1.DeliverySpec">DeliverySpec</a>, 
<a href="#sources.knative.dev/v1alpha1.GitHubSourceSpec">GitHubSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.GitLabSourceSpec">GitLabSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.KafkaSourceSpec">KafkaSourceSpec</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelBranch">ParallelBranch</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelBranch">ParallelBranch</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelSpec">ParallelSpec</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelSpec">ParallelSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.PingSourceSpec">PingSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.PrometheusSourceSpec">PrometheusSourceSpec</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceSpec">SequenceSpec</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceSpec">SequenceSpec</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceStep">SequenceStep</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceStep">SequenceStep</a>, 
<a href="#duck.knative.dev/v1.SourceSpec">SourceSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.SubscriptionSpec">SubscriptionSpec</a>, 
<a href="#messaging.knative.dev/v1beta1.SubscriptionSpec">SubscriptionSpec</a>, 
<a href="#eventing.knative.dev/v1alpha1.TriggerSpec">TriggerSpec</a>, 
<a href="#eventing.knative.dev/v1beta1.TriggerSpec">TriggerSpec</a>)
</p>
<p>
<p>Destination represents a target of an invocation over HTTP.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ref</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Ref points to an Addressable.</p>
</td>
</tr>
<tr>
<td>
<code>uri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.KRShaped">KRShaped
</h3>
<p>
<p>KRShaped is an interface for retrieving the duck elements of an arbitrary resource.</p>
</p>
<h3 id="duck.knative.dev/v1.KReference">KReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.BrokerSpec">BrokerSpec</a>, 
<a href="#eventing.knative.dev/v1alpha1.BrokerSpec">BrokerSpec</a>, 
<a href="#messaging.knative.dev/v1beta1.ChannelStatus">ChannelStatus</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#duck.knative.dev/v1beta1.DeliveryStatus">DeliveryStatus</a>, 
<a href="#duck.knative.dev/v1.Destination">Destination</a>)
</p>
<p>
<p>KReference contains enough information to refer to another object.
It&rsquo;s a trimmed down version of corev1.ObjectReference.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind of the referent.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</a></p>
</td>
</tr>
<tr>
<td>
<code>namespace</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Namespace of the referent.
More info: <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</a>
This is optional field, it gets defaulted to the object holding it if left out.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name of the referent.
More info: <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names">https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</a></p>
</td>
</tr>
<tr>
<td>
<code>apiVersion</code></br>
<em>
string
</em>
</td>
<td>
<p>API version of the referent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.KResource">KResource
</h3>
<p>
<p>KResource is a skeleton type wrapping Conditions in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Conditions ObjectReferences and
access the Conditions data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.PodSpecable">PodSpecable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.WithPodSpec">WithPodSpec</a>)
</p>
<p>
<p>PodSpecable is implemented by types containing a PodTemplateSpec
in the manner of ReplicaSet, Deployment, DaemonSet, StatefulSet.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">
Kubernetes core/v1.PodSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Specification of the desired behavior of the pod.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
<br/>
<br/>
<table>
<tr>
<td>
<code>volumes</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#volume-v1-core">
[]Kubernetes core/v1.Volume
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>List of volumes that can be mounted by containers belonging to the pod.
More info: <a href="https://kubernetes.io/docs/concepts/storage/volumes">https://kubernetes.io/docs/concepts/storage/volumes</a></p>
</td>
</tr>
<tr>
<td>
<code>initContainers</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core">
[]Kubernetes core/v1.Container
</a>
</em>
</td>
<td>
<p>List of initialization containers belonging to the pod.
Init containers are executed in order prior to containers being started. If any
init container fails, the pod is considered to have failed and is handled according
to its restartPolicy. The name for an init container or normal container must be
unique among all containers.
Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
The resourceRequirements of an init container are taken into account during scheduling
by finding the highest request/limit for each resource type, and then using the max of
of that value or the sum of the normal containers. Limits are applied to init containers
in a similar fashion.
Init containers cannot currently be added or removed.
Cannot be updated.
More info: <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">https://kubernetes.io/docs/concepts/workloads/pods/init-containers/</a></p>
</td>
</tr>
<tr>
<td>
<code>containers</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core">
[]Kubernetes core/v1.Container
</a>
</em>
</td>
<td>
<p>List of containers belonging to the pod.
Containers cannot currently be added or removed.
There must be at least one container in a Pod.
Cannot be updated.</p>
</td>
</tr>
<tr>
<td>
<code>ephemeralContainers</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#ephemeralcontainer-v1-core">
[]Kubernetes core/v1.EphemeralContainer
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
pod to perform user-initiated actions such as debugging. This list cannot be specified when
creating a pod, and it cannot be modified by updating the pod spec. In order to add an
ephemeral container to an existing pod, use the pod&rsquo;s ephemeralcontainers subresource.
This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.</p>
</td>
</tr>
<tr>
<td>
<code>restartPolicy</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#restartpolicy-v1-core">
Kubernetes core/v1.RestartPolicy
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Restart policy for all containers within the pod.
One of Always, OnFailure, Never.
Default to Always.
More info: <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy</a></p>
</td>
</tr>
<tr>
<td>
<code>terminationGracePeriodSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
Value must be non-negative integer. The value zero indicates delete immediately.
If this value is nil, the default grace period will be used instead.
The grace period is the duration in seconds after the processes running in the pod are sent
a termination signal and the time when the processes are forcibly halted with a kill signal.
Set this value longer than the expected cleanup time for your process.
Defaults to 30 seconds.</p>
</td>
</tr>
<tr>
<td>
<code>activeDeadlineSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Optional duration in seconds the pod may be active on the node relative to
StartTime before the system will actively try to mark it failed and kill associated containers.
Value must be a positive integer.</p>
</td>
</tr>
<tr>
<td>
<code>dnsPolicy</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#dnspolicy-v1-core">
Kubernetes core/v1.DNSPolicy
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Set DNS policy for the pod.
Defaults to &ldquo;ClusterFirst&rdquo;.
Valid values are &lsquo;ClusterFirstWithHostNet&rsquo;, &lsquo;ClusterFirst&rsquo;, &lsquo;Default&rsquo; or &lsquo;None&rsquo;.
DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
To have DNS options set along with hostNetwork, you have to specify DNS policy
explicitly to &lsquo;ClusterFirstWithHostNet&rsquo;.</p>
</td>
</tr>
<tr>
<td>
<code>nodeSelector</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>NodeSelector is a selector which must be true for the pod to fit on a node.
Selector which must match a node&rsquo;s labels for the pod to be scheduled on that node.
More info: <a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/">https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</a></p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName is the name of the ServiceAccount to use to run this pod.
More info: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</a></p>
</td>
</tr>
<tr>
<td>
<code>serviceAccount</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
Deprecated: Use serviceAccountName instead.</p>
</td>
</tr>
<tr>
<td>
<code>automountServiceAccountToken</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.</p>
</td>
</tr>
<tr>
<td>
<code>nodeName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
the scheduler simply schedules this pod onto that node, assuming that it fits resource
requirements.</p>
</td>
</tr>
<tr>
<td>
<code>hostNetwork</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Host networking requested for this pod. Use the host&rsquo;s network namespace.
If this option is set, the ports that will be used must be specified.
Default to false.</p>
</td>
</tr>
<tr>
<td>
<code>hostPID</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Use the host&rsquo;s pid namespace.
Optional: Default to false.</p>
</td>
</tr>
<tr>
<td>
<code>hostIPC</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Use the host&rsquo;s ipc namespace.
Optional: Default to false.</p>
</td>
</tr>
<tr>
<td>
<code>shareProcessNamespace</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Share a single process namespace between all of the containers in a pod.
When this is set containers will be able to view and signal processes from other containers
in the same pod, and the first process in each container will not be assigned PID 1.
HostPID and ShareProcessNamespace cannot both be set.
Optional: Default to false.
This field is beta-level and may be disabled with the PodShareProcessNamespace feature.</p>
</td>
</tr>
<tr>
<td>
<code>securityContext</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podsecuritycontext-v1-core">
Kubernetes core/v1.PodSecurityContext
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>SecurityContext holds pod-level security attributes and common container settings.
Optional: Defaults to empty.  See type description for default values of each field.</p>
</td>
</tr>
<tr>
<td>
<code>imagePullSecrets</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#localobjectreference-v1-core">
[]Kubernetes core/v1.LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
If specified, these secrets will be passed to individual puller implementations for them to use. For example,
in the case of docker, only DockerConfig type secrets are honored.
More info: <a href="https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod">https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod</a></p>
</td>
</tr>
<tr>
<td>
<code>hostname</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Specifies the hostname of the Pod
If not specified, the pod&rsquo;s hostname will be set to a system-defined value.</p>
</td>
</tr>
<tr>
<td>
<code>subdomain</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, the fully qualified Pod hostname will be &ldquo;<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>&rdquo;.
If not specified, the pod will not have a domainname at all.</p>
</td>
</tr>
<tr>
<td>
<code>affinity</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#affinity-v1-core">
Kubernetes core/v1.Affinity
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, the pod&rsquo;s scheduling constraints</p>
</td>
</tr>
<tr>
<td>
<code>schedulerName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, the pod will be dispatched by specified scheduler.
If not specified, the pod will be dispatched by default scheduler.</p>
</td>
</tr>
<tr>
<td>
<code>tolerations</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#toleration-v1-core">
[]Kubernetes core/v1.Toleration
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, the pod&rsquo;s tolerations.</p>
</td>
</tr>
<tr>
<td>
<code>hostAliases</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#hostalias-v1-core">
[]Kubernetes core/v1.HostAlias
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>HostAliases is an optional list of hosts and IPs that will be injected into the pod&rsquo;s hosts
file if specified. This is only valid for non-hostNetwork pods.</p>
</td>
</tr>
<tr>
<td>
<code>priorityClassName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, indicates the pod&rsquo;s priority. &ldquo;system-node-critical&rdquo; and
&ldquo;system-cluster-critical&rdquo; are two special keywords which indicate the
highest priorities with the former being the highest priority. Any other
name must be defined by creating a PriorityClass object with that name.
If not specified, the pod priority will be default or zero if there is no
default.</p>
</td>
</tr>
<tr>
<td>
<code>priority</code></br>
<em>
int32
</em>
</td>
<td>
<em>(Optional)</em>
<p>The priority value. Various system components use this field to find the
priority of the pod. When Priority Admission Controller is enabled, it
prevents users from setting this field. The admission controller populates
this field from PriorityClassName.
The higher the value, the higher the priority.</p>
</td>
</tr>
<tr>
<td>
<code>dnsConfig</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#poddnsconfig-v1-core">
Kubernetes core/v1.PodDNSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Specifies the DNS parameters of a pod.
Parameters specified here will be merged to the generated DNS
configuration based on DNSPolicy.</p>
</td>
</tr>
<tr>
<td>
<code>readinessGates</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podreadinessgate-v1-core">
[]Kubernetes core/v1.PodReadinessGate
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>If specified, all readiness gates will be evaluated for pod readiness.
A pod is ready when all its containers are ready AND
all conditions specified in the readiness gates have status equal to &ldquo;True&rdquo;
More info: <a href="https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md">https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md</a></p>
</td>
</tr>
<tr>
<td>
<code>runtimeClassName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
If unset or empty, the &ldquo;legacy&rdquo; RuntimeClass will be used, which is an implicit class with an
empty definition that uses the default runtime handler.
More info: <a href="https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md">https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md</a>
This is a beta feature as of Kubernetes v1.14.</p>
</td>
</tr>
<tr>
<td>
<code>enableServiceLinks</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>EnableServiceLinks indicates whether information about services should be injected into pod&rsquo;s
environment variables, matching the syntax of Docker links.
Optional: Defaults to true.</p>
</td>
</tr>
<tr>
<td>
<code>preemptionPolicy</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#preemptionpolicy-v1-core">
Kubernetes core/v1.PreemptionPolicy
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>PreemptionPolicy is the Policy for preempting pods with lower priority.
One of Never, PreemptLowerPriority.
Defaults to PreemptLowerPriority if unset.
This field is alpha-level and is only honored by servers that enable the NonPreemptingPriority feature.</p>
</td>
</tr>
<tr>
<td>
<code>overhead</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#resourcelist-v1-core">
Kubernetes core/v1.ResourceList
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
This field will be autopopulated at admission time by the RuntimeClass admission controller. If
the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
The RuntimeClass admission controller will reject Pod create requests which have the overhead already
set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
More info: <a href="https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md">https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md</a>
This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.</p>
</td>
</tr>
<tr>
<td>
<code>topologySpreadConstraints</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#topologyspreadconstraint-v1-core">
[]Kubernetes core/v1.TopologySpreadConstraint
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TopologySpreadConstraints describes how a group of pods ought to spread across topology
domains. Scheduler will schedule pods in a way which abides by the constraints.
This field is alpha-level and is only honored by clusters that enables the EvenPodsSpread
feature.
All topologySpreadConstraints are ANDed.</p>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.Source">Source
</h3>
<p>
<p>Source is the minimum resource shape to adhere to the Source Specification.
This duck type is intended to allow implementors of Sources and
Importers to verify their own resources meet the expectations.
This is not a real resource.
NOTE: The Source Specification is in progress and the shape and names could
be modified until it has been accepted.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a uri to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.SourceSpec">SourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceSpec">ApiServerSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha2.ContainerSourceSpec">ContainerSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha2.PingSourceSpec">PingSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha2.SinkBindingSpec">SinkBindingSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.SinkBindingSpec">SinkBindingSpec</a>, 
<a href="#duck.knative.dev/v1.Source">Source</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a uri to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.SourceStatus">SourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceStatus">ApiServerSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceStatus">ApiServerSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.AwsSqsSourceStatus">AwsSqsSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha2.ContainerSourceStatus">ContainerSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.CouchDbSourceStatus">CouchDbSourceStatus</a>, 
<a href="#bindings.knative.dev/v1alpha1.GitHubBindingStatus">GitHubBindingStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.GitHubSourceStatus">GitHubSourceStatus</a>, 
<a href="#bindings.knative.dev/v1alpha1.GitLabBindingStatus">GitLabBindingStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.GitLabSourceStatus">GitLabSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.KafkaSourceStatus">KafkaSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.PingSourceStatus">PingSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha2.PingSourceStatus">PingSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.PrometheusSourceStatus">PrometheusSourceStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.SinkBindingStatus">SinkBindingStatus</a>, 
<a href="#sources.knative.dev/v1alpha2.SinkBindingStatus">SinkBindingStatus</a>, 
<a href="#duck.knative.dev/v1.Source">Source</a>)
</p>
<p>
<p>SourceStatus shows how we expect folks to embed Addressable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1beta1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.</p>
</td>
</tr>
<tr>
<td>
<code>sinkUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>SinkURI is the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
<tr>
<td>
<code>ceAttributes</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventAttributes">
[]CloudEventAttributes
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventAttributes are the specific attributes that the Source uses
as part of its CloudEvents.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.Status">Status
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.BrokerStatus">BrokerStatus</a>, 
<a href="#eventing.knative.dev/v1alpha1.BrokerStatus">BrokerStatus</a>, 
<a href="#sources.knative.dev/v1alpha1.CamelSourceStatus">CamelSourceStatus</a>, 
<a href="#networking.internal.knative.dev/v1alpha1.CertificateStatus">CertificateStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.ChannelStatus">ChannelStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedStatus">ChannelableCombinedStatus</a>, 
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatus">ConfigMapPropagationStatus</a>, 
<a href="#serving.knative.dev/v1.ConfigurationStatus">ConfigurationStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.ConfigurationStatus">ConfigurationStatus</a>, 
<a href="#eventing.knative.dev/v1beta1.EventTypeStatus">EventTypeStatus</a>, 
<a href="#eventing.knative.dev/v1alpha1.EventTypeStatus">EventTypeStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelStatus">InMemoryChannelStatus</a>, 
<a href="#networking.internal.knative.dev/v1alpha1.IngressStatus">IngressStatus</a>, 
<a href="#duck.knative.dev/v1.KResource">KResource</a>, 
<a href="#bindings.knative.dev/v1alpha1.KafkaBindingStatus">KafkaBindingStatus</a>, 
<a href="#autoscaling.internal.knative.dev/v1alpha1.MetricStatus">MetricStatus</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelStatus">ParallelStatus</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelStatus">ParallelStatus</a>, 
<a href="#autoscaling.internal.knative.dev/v1alpha1.PodAutoscalerStatus">PodAutoscalerStatus</a>, 
<a href="#serving.knative.dev/v1.RevisionStatus">RevisionStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.RevisionStatus">RevisionStatus</a>, 
<a href="#serving.knative.dev/v1.RouteStatus">RouteStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.RouteStatus">RouteStatus</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceStatus">SequenceStatus</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceStatus">SequenceStatus</a>, 
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceStatus">ServerlessServiceStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.ServiceStatus">ServiceStatus</a>, 
<a href="#serving.knative.dev/v1.ServiceStatus">ServiceStatus</a>, 
<a href="#duck.knative.dev/v1.SourceStatus">SourceStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.SubscriptionStatus">SubscriptionStatus</a>, 
<a href="#messaging.knative.dev/v1beta1.SubscriptionStatus">SubscriptionStatus</a>, 
<a href="#eventing.knative.dev/v1beta1.TriggerStatus">TriggerStatus</a>, 
<a href="#eventing.knative.dev/v1alpha1.TriggerStatus">TriggerStatus</a>)
</p>
<p>
<p>Status shows how we expect folks to embed Conditions in
their Status field.
WARNING: Adding fields to this struct will add them to all Knative resources.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>observedGeneration</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ObservedGeneration is the &lsquo;Generation&rsquo; of the Service that
was last processed by the controller.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#duck.knative.dev/v1.Conditions">
Conditions
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Conditions the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.WithPod">WithPod
</h3>
<p>
<p>WithPod is the shell that demonstrates how PodSpecable types wrap
a PodSpec.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1.WithPodSpec">
WithPodSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#duck.knative.dev/v1.PodSpecable">
PodSpecable
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1.WithPodSpec">WithPodSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1.WithPod">WithPod</a>)
</p>
<p>
<p>WithPodSpec is the shell around the PodSpecable within WithPod.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#duck.knative.dev/v1.PodSpecable">
PodSpecable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="networking.internal.knative.dev/v1alpha1">networking.internal.knative.dev/v1alpha1</h2>
<p>
</p>
Resource Types:
<ul><li>
<a href="#networking.internal.knative.dev/v1alpha1.Certificate">Certificate</a>
</li><li>
<a href="#networking.internal.knative.dev/v1alpha1.Ingress">Ingress</a>
</li><li>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessService">ServerlessService</a>
</li></ul>
<h3 id="networking.internal.knative.dev/v1alpha1.Certificate">Certificate
</h3>
<p>
<p>Certificate is responsible for provisioning a SSL certificate for the
given hosts. It is a Knative abstraction for various SSL certificate
provisioning solutions (such as cert-manager or self-signed SSL certificate).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.internal.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Certificate</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.CertificateSpec">
CertificateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec is the desired state of the Certificate.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
<br/>
<br/>
<table>
<tr>
<td>
<code>dnsNames</code></br>
<em>
[]string
</em>
</td>
<td>
<p>DNSNames is a list of DNS names the Certificate could support.
The wildcard format of DNSNames (e.g. *.default.example.com) is supported.</p>
</td>
</tr>
<tr>
<td>
<code>secretName</code></br>
<em>
string
</em>
</td>
<td>
<p>SecretName is the name of the secret resource to store the SSL certificate in.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.CertificateStatus">
CertificateStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status is the current state of the Certificate.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.Ingress">Ingress
</h3>
<p>
<p>Ingress is a collection of rules that allow inbound connections to reach the endpoints defined
by a backend. An Ingress can be configured to give services externally-reachable URLs, load
balance traffic, offer name based virtual hosting, etc.</p>
<p>This is heavily based on K8s Ingress <a href="https://godoc.org/k8s.io/api/networking/v1beta1#Ingress">https://godoc.org/k8s.io/api/networking/v1beta1#Ingress</a>
which some highlighted modifications.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.internal.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Ingress</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressSpec">
IngressSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec is the desired state of the Ingress.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressTLS">
[]IngressTLS
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS configuration. Currently Ingress only supports a single TLS
port: 443. If multiple members of this list specify different hosts, they
will be multiplexed on the same port according to the hostname specified
through the SNI TLS extension, if the ingress controller fulfilling the
ingress supports SNI.</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressRule">
[]IngressRule
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>A list of host rules used to configure the Ingress.</p>
</td>
</tr>
<tr>
<td>
<code>visibility</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressVisibility">
IngressVisibility
</a>
</em>
</td>
<td>
<p>Visibility setting.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressStatus">
IngressStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status is the current state of the Ingress.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.ServerlessService">ServerlessService
</h3>
<p>
<p>ServerlessService is a proxy for the K8s service objects containing the
endpoints for the revision, whether those are endpoints of the activator or
revision pods.
See: <a href="https://knative.page.link/naxz">https://knative.page.link/naxz</a> for details.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.internal.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>ServerlessService</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Standard object&rsquo;s metadata.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata"</a></p>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceSpec">
ServerlessServiceSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec is the desired state of the ServerlessService.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</a></p>
<br/>
<br/>
<table>
<tr>
<td>
<code>mode</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceOperationMode">
ServerlessServiceOperationMode
</a>
</em>
</td>
<td>
<p>Mode describes the mode of operation of the ServerlessService.</p>
</td>
</tr>
<tr>
<td>
<code>objectRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>ObjectRef defines the resource that this ServerlessService
is responsible for making &ldquo;serverless&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>ProtocolType</code></br>
<em>
knative.dev/serving/pkg/apis/networking.ProtocolType
</em>
</td>
<td>
<p>The application-layer protocol. Matches <code>RevisionProtocolType</code> set on the owning pa/revision.
serving imports networking, so just use string.</p>
</td>
</tr>
<tr>
<td>
<code>numActivators</code></br>
<em>
int32
</em>
</td>
<td>
<p>NumActivators contains number of Activators that this revision should be
assigned.
O means — assign all.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceStatus">
ServerlessServiceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status is the current state of the ServerlessService.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-statuss</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.CertificateSpec">CertificateSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.Certificate">Certificate</a>)
</p>
<p>
<p>CertificateSpec defines the desired state of a <code>Certificate</code>.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>dnsNames</code></br>
<em>
[]string
</em>
</td>
<td>
<p>DNSNames is a list of DNS names the Certificate could support.
The wildcard format of DNSNames (e.g. *.default.example.com) is supported.</p>
</td>
</tr>
<tr>
<td>
<code>secretName</code></br>
<em>
string
</em>
</td>
<td>
<p>SecretName is the name of the secret resource to store the SSL certificate in.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.CertificateStatus">CertificateStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.Certificate">Certificate</a>)
</p>
<p>
<p>CertificateStatus defines the observed state of a <code>Certificate</code>.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>When Certificate status is ready, it means:
- The target secret exists
- The target secret contains a certificate that has not expired
- The target secret contains a private key valid for the certificate</p>
</td>
</tr>
<tr>
<td>
<code>notAfter</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>The expiration time of the TLS certificate stored in the secret named
by this resource in spec.secretName.</p>
</td>
</tr>
<tr>
<td>
<code>http01Challenges</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTP01Challenge">
[]HTTP01Challenge
</a>
</em>
</td>
<td>
<p>HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled
in order to get the TLS certificate..</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.HTTP01Challenge">HTTP01Challenge
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.CertificateStatus">CertificateStatus</a>)
</p>
<p>
<p>HTTP01Challenge defines the status of a HTTP01 challenge that a certificate needs
to fulfill.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>url</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>URL is the URL that the HTTP01 challenge is expected to serve on.</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceName is the name of the service to serve HTTP01 challenge requests.</p>
</td>
</tr>
<tr>
<td>
<code>serviceNamespace</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.</p>
</td>
</tr>
<tr>
<td>
<code>servicePort</code></br>
<em>
k8s.io/apimachinery/pkg/util/intstr.IntOrString
</em>
</td>
<td>
<p>ServicePort is the port of the service to serve HTTP01 challenge requests.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.HTTPIngressPath">HTTPIngressPath
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPIngressRuleValue">HTTPIngressRuleValue</a>)
</p>
<p>
<p>HTTPIngressPath associates a path regex with a backend. Incoming URLs matching
the path are forwarded to the backend.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>path</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Path is an extended POSIX regex as defined by IEEE Std 1003.1,
(i.e this follows the egrep/unix syntax, not the perl syntax)
matched against the path of an incoming request. Currently it can
contain characters disallowed from the conventional &ldquo;path&rdquo;
part of a URL as defined by RFC 3986. Paths must begin with
a &lsquo;/&rsquo;. If unspecified, the path defaults to a catch all sending
traffic to the backend.</p>
</td>
</tr>
<tr>
<td>
<code>splits</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressBackendSplit">
[]IngressBackendSplit
</a>
</em>
</td>
<td>
<p>Splits defines the referenced service endpoints to which the traffic
will be forwarded to.</p>
</td>
</tr>
<tr>
<td>
<code>appendHeaders</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>AppendHeaders allow specifying additional HTTP headers to add
before forwarding a request to the destination service.</p>
<p>NOTE: This differs from K8s Ingress which doesn&rsquo;t allow header appending.</p>
</td>
</tr>
<tr>
<td>
<code>timeout</code></br>
<em>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration">
Kubernetes meta/v1.Duration
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Timeout for HTTP requests.</p>
<p>NOTE: This differs from K8s Ingress which doesn&rsquo;t allow setting timeouts.</p>
</td>
</tr>
<tr>
<td>
<code>retries</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPRetry">
HTTPRetry
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Retry policy for HTTP requests.</p>
<p>NOTE: This differs from K8s Ingress which doesn&rsquo;t allow retry settings.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.HTTPIngressRuleValue">HTTPIngressRuleValue
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressRule">IngressRule</a>)
</p>
<p>
<p>HTTPIngressRuleValue is a list of http selectors pointing to backends.
In the example: http://<host>/<path>?<searchpart> -&gt; backend where
where parts of the url correspond to RFC 3986, this resource will be used
to match against everything after the last &lsquo;/&rsquo; and before the first &lsquo;?&rsquo;
or &lsquo;#&rsquo;.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>paths</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPIngressPath">
[]HTTPIngressPath
</a>
</em>
</td>
<td>
<p>A collection of paths that map requests to backends.</p>
<p>If they are multiple matching paths, the first match takes precendent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.HTTPRetry">HTTPRetry
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPIngressPath">HTTPIngressPath</a>)
</p>
<p>
<p>HTTPRetry describes the retry policy to use when a HTTP request fails.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>attempts</code></br>
<em>
int
</em>
</td>
<td>
<p>Number of retries for a given request.</p>
</td>
</tr>
<tr>
<td>
<code>perTryTimeout</code></br>
<em>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration">
Kubernetes meta/v1.Duration
</a>
</em>
</td>
<td>
<p>Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressBackend">IngressBackend
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressBackendSplit">IngressBackendSplit</a>)
</p>
<p>
<p>IngressBackend describes all endpoints for a given service and port.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceNamespace</code></br>
<em>
string
</em>
</td>
<td>
<p>Specifies the namespace of the referenced service.</p>
<p>NOTE: This differs from K8s Ingress to allow routing to different namespaces.</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<p>Specifies the name of the referenced service.</p>
</td>
</tr>
<tr>
<td>
<code>servicePort</code></br>
<em>
k8s.io/apimachinery/pkg/util/intstr.IntOrString
</em>
</td>
<td>
<p>Specifies the port of the referenced service.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressBackendSplit">IngressBackendSplit
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPIngressPath">HTTPIngressPath</a>)
</p>
<p>
<p>IngressBackendSplit describes all endpoints for a given service and port.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>IngressBackend</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressBackend">
IngressBackend
</a>
</em>
</td>
<td>
<p>
(Members of <code>IngressBackend</code> are embedded into this type.)
</p>
<p>Specifies the backend receiving the traffic split.</p>
</td>
</tr>
<tr>
<td>
<code>percent</code></br>
<em>
int
</em>
</td>
<td>
<p>Specifies the split percentage, a number between 0 and 100.  If
only one split is specified, we default to 100.</p>
<p>NOTE: This differs from K8s Ingress to allow percentage split.</p>
</td>
</tr>
<tr>
<td>
<code>appendHeaders</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>AppendHeaders allow specifying additional HTTP headers to add
before forwarding a request to the destination service.</p>
<p>NOTE: This differs from K8s Ingress which doesn&rsquo;t allow header appending.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressRule">IngressRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressSpec">IngressSpec</a>)
</p>
<p>
<p>IngressRule represents the rules mapping the paths under a specified host to
the related backend services. Incoming requests are first evaluated for a host
match, then routed to the backend associated with the matching IngressRuleValue.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>hosts</code></br>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Host is the fully qualified domain name of a network host, as defined
by RFC 3986. Note the following deviations from the &ldquo;host&rdquo; part of the
URI as defined in the RFC:
1. IPs are not allowed. Currently a rule value can only apply to the
IP in the Spec of the parent .
2. The <code>:</code> delimiter is not respected because ports are not allowed.
Currently the port of an Ingress is implicitly :80 for http and
:443 for https.
Both these may change in the future.
If the host is unspecified, the Ingress routes all traffic based on the
specified IngressRuleValue.
If multiple matching Hosts were provided, the first rule will take precedent.</p>
</td>
</tr>
<tr>
<td>
<code>visibility</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressVisibility">
IngressVisibility
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Visibility signifies whether this rule should <code>ClusterLocal</code>. If it&rsquo;s not
specified then it defaults to <code>ExternalIP</code>.</p>
</td>
</tr>
<tr>
<td>
<code>http</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.HTTPIngressRuleValue">
HTTPIngressRuleValue
</a>
</em>
</td>
<td>
<p>HTTP represents a rule to apply against incoming requests. If the
rule is satisfied, the request is routed to the specified backend.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressSpec">IngressSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.Ingress">Ingress</a>)
</p>
<p>
<p>IngressSpec describes the Ingress the user wishes to exist.</p>
<p>In general this follows the same shape as K8s Ingress.
Some notable differences:
- Backends now can have namespace:
- Traffic can be split across multiple backends.
- Timeout &amp; Retry can be configured.
- Headers can be appended.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedGeneration was used prior in Kubernetes versions <1.11
when metadata.generation was not being incremented by the api server</p>
<p>This property will be dropped in future Knative releases and should
not be used - use metadata.generation</p>
<p>Tracking issue: <a href="https://github.com/knative/serving/issues/643">https://github.com/knative/serving/issues/643</a></p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressTLS">
[]IngressTLS
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS configuration. Currently Ingress only supports a single TLS
port: 443. If multiple members of this list specify different hosts, they
will be multiplexed on the same port according to the hostname specified
through the SNI TLS extension, if the ingress controller fulfilling the
ingress supports SNI.</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressRule">
[]IngressRule
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>A list of host rules used to configure the Ingress.</p>
</td>
</tr>
<tr>
<td>
<code>visibility</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressVisibility">
IngressVisibility
</a>
</em>
</td>
<td>
<p>Visibility setting.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressStatus">IngressStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.Ingress">Ingress</a>)
</p>
<p>
<p>IngressStatus describe the current state of the Ingress.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>loadBalancer</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.LoadBalancerStatus">
LoadBalancerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>LoadBalancer contains the current status of the load-balancer.
This is to be superseded by the combination of <code>PublicLoadBalancer</code> and <code>PrivateLoadBalancer</code></p>
</td>
</tr>
<tr>
<td>
<code>publicLoadBalancer</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.LoadBalancerStatus">
LoadBalancerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>PublicLoadBalancer contains the current status of the load-balancer.</p>
</td>
</tr>
<tr>
<td>
<code>privateLoadBalancer</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.LoadBalancerStatus">
LoadBalancerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>PrivateLoadBalancer contains the current status of the load-balancer.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressTLS">IngressTLS
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressSpec">IngressSpec</a>)
</p>
<p>
<p>IngressTLS describes the transport layer security associated with an Ingress.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>hosts</code></br>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hosts is a list of hosts included in the TLS certificate. The values in
this list must match the name/s used in the tlsSecret. Defaults to the
wildcard host setting for the loadbalancer controller fulfilling this
Ingress, if left unspecified.</p>
</td>
</tr>
<tr>
<td>
<code>secretName</code></br>
<em>
string
</em>
</td>
<td>
<p>SecretName is the name of the secret used to terminate SSL traffic.</p>
</td>
</tr>
<tr>
<td>
<code>secretNamespace</code></br>
<em>
string
</em>
</td>
<td>
<p>SecretNamespace is the namespace of the secret used to terminate SSL traffic.</p>
</td>
</tr>
<tr>
<td>
<code>serverCertificate</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServerCertificate identifies the certificate filename in the secret.
Defaults to <code>tls.crt</code>.</p>
</td>
</tr>
<tr>
<td>
<code>privateKey</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>PrivateKey identifies the private key filename in the secret.
Defaults to <code>tls.key</code>.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.IngressVisibility">IngressVisibility
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressRule">IngressRule</a>, 
<a href="#networking.internal.knative.dev/v1alpha1.IngressSpec">IngressSpec</a>)
</p>
<p>
<p>IngressVisibility describes whether the Ingress should be exposed to
public gateways or not.</p>
</p>
<h3 id="networking.internal.knative.dev/v1alpha1.LoadBalancerIngressStatus">LoadBalancerIngressStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.LoadBalancerStatus">LoadBalancerStatus</a>)
</p>
<p>
<p>LoadBalancerIngressStatus represents the status of a load-balancer ingress point:
traffic intended for the service should be sent to an ingress point.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ip</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>IP is set for load-balancer ingress points that are IP based
(typically GCE or OpenStack load-balancers)</p>
</td>
</tr>
<tr>
<td>
<code>domain</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Domain is set for load-balancer ingress points that are DNS based
(typically AWS load-balancers)</p>
</td>
</tr>
<tr>
<td>
<code>domainInternal</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>DomainInternal is set if there is a cluster-local DNS name to access the Ingress.</p>
<p>NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
DNS name to allow routing in case of not having a mesh.</p>
</td>
</tr>
<tr>
<td>
<code>meshOnly</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>MeshOnly is set if the Ingress is only load-balanced through a Service mesh.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.LoadBalancerStatus">LoadBalancerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.IngressStatus">IngressStatus</a>)
</p>
<p>
<p>LoadBalancerStatus represents the status of a load-balancer.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ingress</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.LoadBalancerIngressStatus">
[]LoadBalancerIngressStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Ingress is a list containing ingress points for the load-balancer.
Traffic intended for the service should be sent to these ingress points.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.ServerlessServiceOperationMode">ServerlessServiceOperationMode
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceSpec">ServerlessServiceSpec</a>)
</p>
<p>
<p>ServerlessServiceOperationMode is an enumeration of the modes of operation
for the ServerlessService.</p>
</p>
<h3 id="networking.internal.knative.dev/v1alpha1.ServerlessServiceSpec">ServerlessServiceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessService">ServerlessService</a>)
</p>
<p>
<p>ServerlessServiceSpec describes the ServerlessService.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>mode</code></br>
<em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessServiceOperationMode">
ServerlessServiceOperationMode
</a>
</em>
</td>
<td>
<p>Mode describes the mode of operation of the ServerlessService.</p>
</td>
</tr>
<tr>
<td>
<code>objectRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>ObjectRef defines the resource that this ServerlessService
is responsible for making &ldquo;serverless&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>ProtocolType</code></br>
<em>
knative.dev/serving/pkg/apis/networking.ProtocolType
</em>
</td>
<td>
<p>The application-layer protocol. Matches <code>RevisionProtocolType</code> set on the owning pa/revision.
serving imports networking, so just use string.</p>
</td>
</tr>
<tr>
<td>
<code>numActivators</code></br>
<em>
int32
</em>
</td>
<td>
<p>NumActivators contains number of Activators that this revision should be
assigned.
O means — assign all.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.internal.knative.dev/v1alpha1.ServerlessServiceStatus">ServerlessServiceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.internal.knative.dev/v1alpha1.ServerlessService">ServerlessService</a>)
</p>
<p>
<p>ServerlessServiceStatus describes the current state of the ServerlessService.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName holds the name of a core K8s Service resource that
load balances over the pods backing this Revision (activator or revision).</p>
</td>
</tr>
<tr>
<td>
<code>privateServiceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>PrivateServiceName holds the name of a core K8s Service resource that
load balances over the user service pods backing this Revision.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="serving.knative.dev/v1beta1">serving.knative.dev/v1beta1</h2>
<p>
</p>
Resource Types:
<ul><li>
<a href="#serving.knative.dev/v1beta1.Configuration">Configuration</a>
</li><li>
<a href="#serving.knative.dev/v1beta1.Revision">Revision</a>
</li><li>
<a href="#serving.knative.dev/v1beta1.Route">Route</a>
</li><li>
<a href="#serving.knative.dev/v1beta1.Service">Service</a>
</li></ul>
<h3 id="serving.knative.dev/v1beta1.Configuration">Configuration
</h3>
<p>
<p>Configuration represents the &ldquo;floating HEAD&rdquo; of a linear history of Revisions.
Users create new Revisions by updating the Configuration&rsquo;s spec.
The &ldquo;latest created&rdquo; revision&rsquo;s name is available under status, as is the
&ldquo;latest ready&rdquo; revision&rsquo;s name.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration">https://github.com/knative/serving/blob/master/docs/spec/overview.md#configuration</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Configuration</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>template</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionTemplateSpec">
RevisionTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Template holds the latest specification for the Revision to be stamped out.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationStatus">
ConfigurationStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1beta1.Revision">Revision
</h3>
<p>
<p>Revision is an immutable snapshot of code and configuration.  A revision
references a container image. Revisions are created by updates to a
Configuration.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision">https://github.com/knative/serving/blob/master/docs/spec/overview.md#revision</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Revision</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionSpec">
RevisionSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>PodSpec</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">
Kubernetes core/v1.PodSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>PodSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>containerConcurrency</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
requests per container of the Revision.  Defaults to <code>0</code> which means
concurrency to the application is not limited, and the system decides the
target concurrency for the autoscaler.</p>
</td>
</tr>
<tr>
<td>
<code>timeoutSeconds</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TimeoutSeconds holds the max duration the instance is allowed for
responding to a request.  If unspecified, a system default will
be provided.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.RevisionStatus">
RevisionStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1beta1.Route">Route
</h3>
<p>
<p>Route is responsible for configuring ingress over a collection of Revisions.
Some of the Revisions a Route distributes traffic over may be specified by
referencing the Configuration responsible for creating them; in these cases
the Route is additionally responsible for monitoring the Configuration for
&ldquo;latest ready revision&rdquo; changes, and smoothly rolling out latest revisions.
See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#route">https://github.com/knative/serving/blob/master/docs/spec/overview.md#route</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Route</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec holds the desired state of the Route (from the client).</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>traffic</code></br>
<em>
<a href="#serving.knative.dev/v1.TrafficTarget">
[]TrafficTarget
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Traffic specifies how to distribute traffic over a collection of
revisions and configurations.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status communicates the observed state of the Route (from the controller).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="serving.knative.dev/v1beta1.Service">Service
</h3>
<p>
<p>Service acts as a top-level container that manages a Route and Configuration
which implement a network service. Service exists to provide a singular
abstraction which can be access controlled, reasoned about, and which
encapsulates software lifecycle decisions such as rollout policy and
team resource ownership. Service acts only as an orchestrator of the
underlying Routes and Configurations (much as a kubernetes Deployment
orchestrates ReplicaSets), and its usage is optional but recommended.</p>
<p>The Service&rsquo;s controller will track the statuses of its owned Configuration
and Route, reflecting their statuses and conditions as its own.</p>
<p>See also: <a href="https://github.com/knative/serving/blob/master/docs/spec/overview.md#service">https://github.com/knative/serving/blob/master/docs/spec/overview.md#service</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
serving.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Service</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#serving.knative.dev/v1.ServiceSpec">
ServiceSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<br/>
<br/>
<table>
<tr>
<td>
<code>ConfigurationSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.ConfigurationSpec">
ConfigurationSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ConfigurationSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines an unrestricted ConfigurationSpec.</p>
</td>
</tr>
<tr>
<td>
<code>RouteSpec</code></br>
<em>
<a href="#serving.knative.dev/v1.RouteSpec">
RouteSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteSpec</code> are embedded into this type.)
</p>
<p>ServiceSpec inlines RouteSpec and restricts/defaults its fields
via webhook.  In particular, this spec can only reference this
Service&rsquo;s configuration and revisions (which also influences
defaults).</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#serving.knative.dev/v1.ServiceStatus">
ServiceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="eventing.knative.dev/v1alpha1">eventing.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 is the v1alpha1 version of the API.</p>
</p>
Resource Types:
<ul><li>
<a href="#eventing.knative.dev/v1alpha1.Broker">Broker</a>
</li><li>
<a href="#eventing.knative.dev/v1alpha1.EventType">EventType</a>
</li><li>
<a href="#eventing.knative.dev/v1alpha1.Trigger">Trigger</a>
</li></ul>
<h3 id="eventing.knative.dev/v1alpha1.Broker">Broker
</h3>
<p>
<p>Broker collects a pool of events that are consumable using Triggers. Brokers
provide a well-known endpoint for event delivery that senders can use with
minimal knowledge of the event routing strategy. Receivers use Triggers to
request delivery of events from a Broker&rsquo;s pool to a specific URL or
Addressable endpoint.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Broker</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.BrokerSpec">
BrokerSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Broker.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>channelTemplateSpec</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use to create all the Channels used internally by the
Broker. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there
are no defaults for the namespace).
Deprecated: See spec.config to configure aditional broker options.
Unless class is <TBD> for channel based broker implementation.</p>
</td>
</tr>
<tr>
<td>
<code>config</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Config is a KReference to the configuration that specifies
configuration options for this Broker. For example, this could be
a pointer to a ConfigMap.
NOTE: this is for backwards compatibility with v1alpha1 &lt;-&gt; v1beta1 conversions.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification to be used internally by the broker to
create subscriptions.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.BrokerStatus">
BrokerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Broker. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.EventType">EventType
</h3>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>EventType</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.EventTypeSpec">
EventTypeSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the EventType.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
<p>Type represents the CloudEvents type. It is authoritative.</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Source is a URI, it represents the CloudEvents source.</p>
</td>
</tr>
<tr>
<td>
<code>schema</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schema is a URI, it represents the CloudEvents schemaurl extension attribute.
It may be a JSON schema, a protobuf schema, etc. It is optional.</p>
</td>
</tr>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO remove <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a>
Broker refers to the Broker that can provide the EventType.</p>
</td>
</tr>
<tr>
<td>
<code>description</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Description is an optional field used to describe the EventType, in any meaningful way.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.EventTypeStatus">
EventTypeStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the EventType.
This data may be out of date.
TODO might be removed <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.Trigger">Trigger
</h3>
<p>
<p>Trigger represents a request to have events delivered to a consumer from a
Broker&rsquo;s event pool.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Trigger</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerSpec">
TriggerSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Trigger.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<p>Broker is the broker that this trigger receives events from. If not specified, will default
to &lsquo;default&rsquo;.</p>
</td>
</tr>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilter">
TriggerFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filter is the filter to apply against all events from the Broker. Only events that pass this
filter will be sent to the Subscriber. If not specified, will default to allowing all events.</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber is the addressable that receives events from the Broker that pass the Filter. It
is required.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerStatus">
TriggerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Trigger. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.BrokerSpec">BrokerSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.Broker">Broker</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channelTemplateSpec</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use to create all the Channels used internally by the
Broker. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there
are no defaults for the namespace).
Deprecated: See spec.config to configure aditional broker options.
Unless class is <TBD> for channel based broker implementation.</p>
</td>
</tr>
<tr>
<td>
<code>config</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Config is a KReference to the configuration that specifies
configuration options for this Broker. For example, this could be
a pointer to a ConfigMap.
NOTE: this is for backwards compatibility with v1alpha1 &lt;-&gt; v1beta1 conversions.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification to be used internally by the broker to
create subscriptions.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.BrokerStatus">BrokerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.Broker">Broker</a>)
</p>
<p>
<p>BrokerStatus represents the current state of a Broker.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Addressable">
Addressable
</a>
</em>
</td>
<td>
<p>Broker is Addressable. It currently exposes the endpoint as a
fully-qualified DNS name which will distribute traffic over the
provided targets from inside the cluster.</p>
<p>It generally has the form {broker}-router.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
<tr>
<td>
<code>triggerChannel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>TriggerChannel is an objectref to the object for the TriggerChannel</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.EventTypeSpec">EventTypeSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.EventType">EventType</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
<p>Type represents the CloudEvents type. It is authoritative.</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Source is a URI, it represents the CloudEvents source.</p>
</td>
</tr>
<tr>
<td>
<code>schema</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schema is a URI, it represents the CloudEvents schemaurl extension attribute.
It may be a JSON schema, a protobuf schema, etc. It is optional.</p>
</td>
</tr>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO remove <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a>
Broker refers to the Broker that can provide the EventType.</p>
</td>
</tr>
<tr>
<td>
<code>description</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Description is an optional field used to describe the EventType, in any meaningful way.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.EventTypeStatus">EventTypeStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.EventType">EventType</a>)
</p>
<p>
<p>EventTypeStatus represents the current state of a EventType.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.TriggerFilter">TriggerFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.TriggerSpec">TriggerSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>sourceAndType</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilterSourceAndType">
TriggerFilterSourceAndType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeprecatedSourceAndType filters events based on exact matches on the
CloudEvents type and source attributes. This field has been replaced by the
Attributes field.</p>
</td>
</tr>
<tr>
<td>
<code>attributes</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilterAttributes">
TriggerFilterAttributes
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Attributes filters events by exact match on event context attributes.
Each key in the map is compared with the equivalent key in the event
context. An event passes the filter if all values are equal to the
specified values.</p>
<p>Nested context attributes are not supported as keys. Only string values are supported.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.TriggerFilterAttributes">TriggerFilterAttributes
(<code>map[string]string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilter">TriggerFilter</a>)
</p>
<p>
<p>TriggerFilterAttributes is a map of context attribute names to values for
filtering by equality. Only exact matches will pass the filter. You can use the value &ldquo;
to indicate all strings match.</p>
</p>
<h3 id="eventing.knative.dev/v1alpha1.TriggerFilterSourceAndType">TriggerFilterSourceAndType
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilter">TriggerFilter</a>)
</p>
<p>
<p>TriggerFilterSourceAndType filters events based on exact matches on the cloud event&rsquo;s type and
source attributes. Only exact matches will pass the filter. Either or both type and source can
use the value &ldquo; to indicate all strings match.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.TriggerSpec">TriggerSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.Trigger">Trigger</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<p>Broker is the broker that this trigger receives events from. If not specified, will default
to &lsquo;default&rsquo;.</p>
</td>
</tr>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#eventing.knative.dev/v1alpha1.TriggerFilter">
TriggerFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filter is the filter to apply against all events from the Broker. Only events that pass this
filter will be sent to the Subscriber. If not specified, will default to allowing all events.</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber is the addressable that receives events from the Broker that pass the Filter. It
is required.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1alpha1.TriggerStatus">TriggerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.Trigger">Trigger</a>)
</p>
<p>
<p>TriggerStatus represents the current state of a Trigger.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>SubscriberURI is the resolved URI of the receiver for this Trigger.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="flows.knative.dev/v1alpha1">flows.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 is the v1alpha1 version of the API.</p>
</p>
Resource Types:
<ul></ul>
<h3 id="flows.knative.dev/v1alpha1.Parallel">Parallel
</h3>
<p>
<p>Parallel defines conditional branches that will be wired in
series through Channels and Subscriptions.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelSpec">
ParallelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Parallel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>branches</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelBranch">
[]ParallelBranch
</a>
</em>
</td>
<td>
<p>Branches is the list of Filter/Subscribers pairs.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of a case Subscriber gets sent to
when the case does not have a Reply</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelStatus">
ParallelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Parallel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelBranch">ParallelBranch
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.ParallelSpec">ParallelSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Filter is the expression guarding the branch</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber receiving the event when the filter passes</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of Subscriber of this case gets sent to.
If not specified, sent the result to the Parallel Reply</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for events to the subscriber
This includes things like retries, DLQ, etc.
Needed for Roundtripping v1alpha1 &lt;-&gt; v1beta1.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelBranchStatus">ParallelBranchStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.ParallelStatus">ParallelStatus</a>)
</p>
<p>
<p>ParallelBranchStatus represents the current state of a Parallel branch</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>filterSubscriptionStatus</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelSubscriptionStatus">
ParallelSubscriptionStatus
</a>
</em>
</td>
<td>
<p>FilterSubscriptionStatus corresponds to the filter subscription status.</p>
</td>
</tr>
<tr>
<td>
<code>filterChannelStatus</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelChannelStatus">
ParallelChannelStatus
</a>
</em>
</td>
<td>
<p>FilterChannelStatus corresponds to the filter channel status.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberSubscriptionStatus</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelSubscriptionStatus">
ParallelSubscriptionStatus
</a>
</em>
</td>
<td>
<p>SubscriptionStatus corresponds to the subscriber subscription status.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelChannelStatus">ParallelChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.ParallelBranchStatus">ParallelBranchStatus</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelStatus">ParallelStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Channel is the reference to the underlying channel.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Channel is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelSpec">ParallelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.Parallel">Parallel</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>branches</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelBranch">
[]ParallelBranch
</a>
</em>
</td>
<td>
<p>Branches is the list of Filter/Subscribers pairs.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of a case Subscriber gets sent to
when the case does not have a Reply</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelStatus">ParallelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.Parallel">Parallel</a>)
</p>
<p>
<p>ParallelStatus represents the current state of a Parallel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>ingressChannelStatus</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelChannelStatus">
ParallelChannelStatus
</a>
</em>
</td>
<td>
<p>IngressChannelStatus corresponds to the ingress channel status.</p>
</td>
</tr>
<tr>
<td>
<code>branchStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.ParallelBranchStatus">
[]ParallelBranchStatus
</a>
</em>
</td>
<td>
<p>BranchStatuses is an array of corresponding to branch statuses.
Matches the Spec.Branches array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the starting point to this Parallel. Sending to this
will target the first subscriber.
It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.ParallelSubscriptionStatus">ParallelSubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.ParallelBranchStatus">ParallelBranchStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscription</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Subscription is the reference to the underlying Subscription.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Subscription is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.Sequence">Sequence
</h3>
<p>
<p>Sequence defines a sequence of Subscribers that will be wired in
series through Channels and Subscriptions.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceSpec">
SequenceSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Sequence.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>steps</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceStep">
[]SequenceStep
</a>
</em>
</td>
<td>
<p>Steps is the list of Destinations (processors / functions) that will be called in the order
provided.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of the last Subscriber gets sent to.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceStatus">
SequenceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Sequence. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.SequenceChannelStatus">SequenceChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.SequenceStatus">SequenceStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Channel is the reference to the underlying channel.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Channel is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.SequenceSpec">SequenceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.Sequence">Sequence</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>steps</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceStep">
[]SequenceStep
</a>
</em>
</td>
<td>
<p>Steps is the list of Destinations (processors / functions) that will be called in the order
provided.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of the last Subscriber gets sent to.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.SequenceStatus">SequenceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.Sequence">Sequence</a>)
</p>
<p>
<p>SequenceStatus represents the current state of a Sequence.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>subscriptionStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceSubscriptionStatus">
[]SequenceSubscriptionStatus
</a>
</em>
</td>
<td>
<p>SubscriptionStatuses is an array of corresponding Subscription statuses.
Matches the Spec.Steps array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>channelStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1alpha1.SequenceChannelStatus">
[]SequenceChannelStatus
</a>
</em>
</td>
<td>
<p>ChannelStatuses is an array of corresponding Channel statuses.
Matches the Spec.Steps array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the starting point to this Sequence. Sending to this
will target the first subscriber.
It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.SequenceStep">SequenceStep
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.SequenceSpec">SequenceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Destination</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>
(Members of <code>Destination</code> are embedded into this type.)
</p>
<p>Subscriber receiving the step event</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for events to the subscriber
This includes things like retries, DLQ, etc.
Needed for Roundtripping v1alpha1 &lt;-&gt; v1beta1.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1alpha1.SequenceSubscriptionStatus">SequenceSubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1alpha1.SequenceStatus">SequenceStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscription</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Subscription is the reference to the underlying Subscription.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Subscription is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="messaging.knative.dev/v1beta1">messaging.knative.dev/v1beta1</h2>
<p>
<p>Package v1beta1 is the v1beta1 version of the API.</p>
</p>
Resource Types:
<ul><li>
<a href="#messaging.knative.dev/v1beta1.Channel">Channel</a>
</li><li>
<a href="#messaging.knative.dev/v1beta1.InMemoryChannel">InMemoryChannel</a>
</li><li>
<a href="#messaging.knative.dev/v1beta1.Subscription">Subscription</a>
</li></ul>
<h3 id="messaging.knative.dev/v1beta1.Channel">Channel
</h3>
<p>
<p>Channel represents a generic Channel. It is normally used when we want a Channel, but don&rsquo;t need a specific Channel implementation.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Channel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelSpec">
ChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<p>ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel.
This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.</p>
</td>
</tr>
<tr>
<td>
<code>ChannelableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableSpec</code> are embedded into this type.)
</p>
<p>Channel conforms to ChannelableSpec</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelStatus">
ChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Channel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.InMemoryChannel">InMemoryChannel
</h3>
<p>
<p>InMemoryChannel is a resource representing an in memory channel</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>InMemoryChannel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.InMemoryChannelSpec">
InMemoryChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>ChannelableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableSpec</code> are embedded into this type.)
</p>
<p>Channel conforms to Duck type Channelable.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.InMemoryChannelStatus">
InMemoryChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Channel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.Subscription">Subscription
</h3>
<p>
<p>Subscription routes events received on a Channel to a DNS name and
corresponds to the subscriptions.channels.knative.dev CRD.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Subscription</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.SubscriptionSpec">
SubscriptionSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Reference to a channel that will be used to create the subscription
You can specify only the following fields of the ObjectReference:
- Kind
- APIVersion
- Name
The resource pointed by this ObjectReference must meet the
contract to the ChannelableSpec duck type. If the resource does not
meet this contract it will be reflected in the Subscription&rsquo;s status.</p>
<p>This field is immutable. We have no good answer on what happens to
the events that are currently in the channel being consumed from
and what the semantics there should be. For now, you can always
delete the Subscription and recreate it to point to a different
channel, giving the user more control over what semantics should
be used (drain the channel first, possibly have events dropped,
etc.)</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Subscriber is reference to (optional) function for processing events.
Events from the Channel will be delivered here and replies are
sent to a Destination as specified by the Reply.</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply specifies (optionally) how to handle events returned from
the Subscriber target.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery configuration</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.SubscriptionStatus">
SubscriptionStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.ChannelDefaulter">ChannelDefaulter
</h3>
<p>
<p>ChannelDefaulter sets the default Channel CRD and Arguments on Channels that do not
specify any implementation.</p>
</p>
<h3 id="messaging.knative.dev/v1beta1.ChannelSpec">ChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.Channel">Channel</a>)
</p>
<p>
<p>ChannelSpec defines which subscribers have expressed interest in receiving events from this Channel.
It also defines the ChannelTemplate to use in order to create the CRD Channel backing this Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<p>ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel.
This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.</p>
</td>
</tr>
<tr>
<td>
<code>ChannelableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableSpec</code> are embedded into this type.)
</p>
<p>Channel conforms to ChannelableSpec</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.ChannelStatus">ChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.Channel">Channel</a>)
</p>
<p>
<p>ChannelStatus represents the current state of a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ChannelableStatus</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">
ChannelableStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableStatus</code> are embedded into this type.)
</p>
<p>Channel conforms to ChannelableStatus</p>
</td>
</tr>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<p>Channel is an KReference to the Channel CRD backing this Channel.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.ChannelTemplateSpec">ChannelTemplateSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1alpha1.BrokerSpec">BrokerSpec</a>, 
<a href="#messaging.knative.dev/v1beta1.ChannelSpec">ChannelSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.ChannelSpec">ChannelSpec</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelSpec">ParallelSpec</a>, 
<a href="#flows.knative.dev/v1alpha1.ParallelSpec">ParallelSpec</a>, 
<a href="#flows.knative.dev/v1beta1.SequenceSpec">SequenceSpec</a>, 
<a href="#flows.knative.dev/v1alpha1.SequenceSpec">SequenceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>spec</code></br>
<em>
k8s.io/apimachinery/pkg/runtime.RawExtension
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec defines the Spec to use for each channel created. Passed
in verbatim to the Channel CRD as Spec section.</p>
<br/>
<br/>
<table>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.ChannelTemplateSpecInternal">ChannelTemplateSpecInternal
</h3>
<p>
<p>ChannelTemplateSpecInternal is an internal only version that includes ObjectMeta so that
we can easily create new Channels off of it.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
k8s.io/apimachinery/pkg/runtime.RawExtension
</em>
</td>
<td>
<em>(Optional)</em>
<p>Spec defines the Spec to use for each channel created. Passed
in verbatim to the Channel CRD as Spec section.</p>
<br/>
<br/>
<table>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.InMemoryChannelSpec">InMemoryChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.InMemoryChannel">InMemoryChannel</a>)
</p>
<p>
<p>InMemoryChannelSpec defines which subscribers have expressed interest in
receiving events from this InMemoryChannel.
arguments for a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ChannelableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableSpec</code> are embedded into this type.)
</p>
<p>Channel conforms to Duck type Channelable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.InMemoryChannelStatus">InMemoryChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.InMemoryChannel">InMemoryChannel</a>)
</p>
<p>
<p>ChannelStatus represents the current state of a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ChannelableStatus</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.ChannelableStatus">
ChannelableStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>ChannelableStatus</code> are embedded into this type.)
</p>
<p>Channel conforms to Duck type Channelable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.SubscriptionSpec">SubscriptionSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.Subscription">Subscription</a>)
</p>
<p>
<p>SubscriptionSpec specifies the Channel for incoming events, a Subscriber target
for processing those events and where to put the result of the processing. Only
From (where the events are coming from) is always required. You can optionally
only Process the events (results in no output events) by leaving out the Result.
You can also perform an identity transformation on the incoming events by leaving
out the Subscriber and only specifying Result.</p>
<p>The following are all valid specifications:
channel &ndash;[subscriber]&ndash;&gt; reply
Sink, no outgoing events:
channel &ndash; subscriber
no-op function (identity transformation):
channel &ndash;&gt; reply</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Reference to a channel that will be used to create the subscription
You can specify only the following fields of the ObjectReference:
- Kind
- APIVersion
- Name
The resource pointed by this ObjectReference must meet the
contract to the ChannelableSpec duck type. If the resource does not
meet this contract it will be reflected in the Subscription&rsquo;s status.</p>
<p>This field is immutable. We have no good answer on what happens to
the events that are currently in the channel being consumed from
and what the semantics there should be. For now, you can always
delete the Subscription and recreate it to point to a different
channel, giving the user more control over what semantics should
be used (drain the channel first, possibly have events dropped,
etc.)</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Subscriber is reference to (optional) function for processing events.
Events from the Channel will be delivered here and replies are
sent to a Destination as specified by the Reply.</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply specifies (optionally) how to handle events returned from
the Subscriber target.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery configuration</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.SubscriptionStatus">SubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.Subscription">Subscription</a>)
</p>
<p>
<p>SubscriptionStatus (computed) for a subscription</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>physicalSubscription</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.SubscriptionStatusPhysicalSubscription">
SubscriptionStatusPhysicalSubscription
</a>
</em>
</td>
<td>
<p>PhysicalSubscription is the fully resolved values that this Subscription represents.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1beta1.SubscriptionStatusPhysicalSubscription">SubscriptionStatusPhysicalSubscription
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1beta1.SubscriptionStatus">SubscriptionStatus</a>)
</p>
<p>
<p>SubscriptionStatusPhysicalSubscription represents the fully resolved values for this
Subscription.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscriberUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>SubscriberURI is the fully resolved URI for spec.subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>replyUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>ReplyURI is the fully resolved URI for the spec.reply.</p>
</td>
</tr>
<tr>
<td>
<code>deadLetterSinkUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="sources.knative.dev/v1alpha2">sources.knative.dev/v1alpha2</h2>
<p>
<p>Package v1alpha2 contains API Schema definitions for the sources v1beta1 API group</p>
</p>
Resource Types:
<ul><li>
<a href="#sources.knative.dev/v1alpha2.ApiServerSource">ApiServerSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha2.ContainerSource">ContainerSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha2.PingSource">PingSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha2.SinkBinding">SinkBinding</a>
</li></ul>
<h3 id="sources.knative.dev/v1alpha2.ApiServerSource">ApiServerSource
</h3>
<p>
<p>ApiServerSource is the Schema for the apiserversources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha2
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>ApiServerSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceSpec">
ApiServerSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKindSelector">
[]APIVersionKindSelector
</a>
</em>
</td>
<td>
<p>Resource are the resources this source will track and send related
lifecycle events from the Kubernetes ApiServer, with an optional label
selector to help filter.</p>
</td>
</tr>
<tr>
<td>
<code>owner</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKind">
APIVersionKind
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ResourceOwner is an additional filter to only track resources that are
owned by a specific resource type. If ResourceOwner matches Resources[n]
then Resources[n] is allowed to pass the ResourceOwner filter.</p>
</td>
</tr>
<tr>
<td>
<code>mode</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>EventMode controls the format of the event.
<code>Reference</code> sends a dataref event type for the resource under watch.
<code>Resource</code> send the full resource lifecycle event.
Defaults to <code>Reference</code></p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName is the name of the ServiceAccount to use to run this
source. Defaults to default if not set.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceStatus">
ApiServerSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.ContainerSource">ContainerSource
</h3>
<p>
<p>ContainerSource is the Schema for the containersources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha2
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>ContainerSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.ContainerSourceSpec">
ContainerSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podtemplatespec-v1-core">
Kubernetes core/v1.PodTemplateSpec
</a>
</em>
</td>
<td>
<p>Template describes the pods that will be created</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.ContainerSourceStatus">
ContainerSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.PingSource">PingSource
</h3>
<p>
<p>PingSource is the Schema for the PingSources API.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha2
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>PingSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.PingSourceSpec">
PingSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schedule is the cronjob schedule. Defaults to <code>* * * * *</code>.</p>
</td>
</tr>
<tr>
<td>
<code>jsonData</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>JsonData is json encoded data used as the body of the event posted to
the sink. Default is empty. If set, datacontenttype will also be set
to &ldquo;application/json&rdquo;.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.PingSourceStatus">
PingSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.SinkBinding">SinkBinding
</h3>
<p>
<p>SinkBinding describes a Binding that is also a Source.
The <code>sink</code> (from the Source duck) is resolved to a URL and
then projected into the <code>subject</code> by augmenting the runtime
contract of the referenced containers to have a <code>K_SINK</code>
environment variable holding the endpoint to which to send
cloud events.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha2
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>SinkBinding</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.SinkBindingSpec">
SinkBindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1alpha1 BindingSpec, which currently provides:
* Subject - Subject references the resource(s) whose &ldquo;runtime contract&rdquo;
should be augmented by Binding implementations.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.SinkBindingStatus">
SinkBindingStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.APIVersionKind">APIVersionKind
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceSpec">ApiServerSourceSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceSpec">ApiServerSourceSpec</a>)
</p>
<p>
<p>APIVersionKind is an APIVersion and Kind tuple.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
<em>
string
</em>
</td>
<td>
<p>APIVersion - the API version of the resource to watch.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind of the resource to watch.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.APIVersionKindSelector">APIVersionKindSelector
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSourceSpec">ApiServerSourceSpec</a>)
</p>
<p>
<p>APIVersionKindSelector is an APIVersion Kind tuple with a LabelSelector.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
<em>
string
</em>
</td>
<td>
<p>APIVersion - the API version of the resource to watch.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind of the resource to watch.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</a></p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>LabelSelector filters this source to objects to those resources pass the
label selector.
More info: <a href="http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors">http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.ApiServerSourceSpec">ApiServerSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSource">ApiServerSource</a>)
</p>
<p>
<p>ApiServerSourceSpec defines the desired state of ApiServerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKindSelector">
[]APIVersionKindSelector
</a>
</em>
</td>
<td>
<p>Resource are the resources this source will track and send related
lifecycle events from the Kubernetes ApiServer, with an optional label
selector to help filter.</p>
</td>
</tr>
<tr>
<td>
<code>owner</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKind">
APIVersionKind
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ResourceOwner is an additional filter to only track resources that are
owned by a specific resource type. If ResourceOwner matches Resources[n]
then Resources[n] is allowed to pass the ResourceOwner filter.</p>
</td>
</tr>
<tr>
<td>
<code>mode</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>EventMode controls the format of the event.
<code>Reference</code> sends a dataref event type for the resource under watch.
<code>Resource</code> send the full resource lifecycle event.
Defaults to <code>Reference</code></p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName is the name of the ServiceAccount to use to run this
source. Defaults to default if not set.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.ApiServerSourceStatus">ApiServerSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ApiServerSource">ApiServerSource</a>)
</p>
<p>
<p>ApiServerSourceStatus defines the observed state of ApiServerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.ContainerSourceSpec">ContainerSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ContainerSource">ContainerSource</a>)
</p>
<p>
<p>ContainerSourceSpec defines the desired state of ContainerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>template</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podtemplatespec-v1-core">
Kubernetes core/v1.PodTemplateSpec
</a>
</em>
</td>
<td>
<p>Template describes the pods that will be created</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.ContainerSourceStatus">ContainerSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.ContainerSource">ContainerSource</a>)
</p>
<p>
<p>ContainerSourceStatus defines the observed state of ContainerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.PingSourceSpec">PingSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.PingSource">PingSource</a>)
</p>
<p>
<p>PingSourceSpec defines the desired state of the PingSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schedule is the cronjob schedule. Defaults to <code>* * * * *</code>.</p>
</td>
</tr>
<tr>
<td>
<code>jsonData</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>JsonData is json encoded data used as the body of the event posted to
the sink. Default is empty. If set, datacontenttype will also be set
to &ldquo;application/json&rdquo;.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.PingSourceStatus">PingSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.PingSource">PingSource</a>)
</p>
<p>
<p>PingSourceStatus defines the observed state of PingSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.SinkBindingSpec">SinkBindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.SinkBinding">SinkBinding</a>)
</p>
<p>
<p>SinkBindingSpec holds the desired state of the SinkBinding (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceSpec, which currently provides:
* Sink - a reference to an object that will resolve to a domain name or
a URI directly to use as the sink.
* CloudEventOverrides - defines overrides to control the output format
and modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
<p>inherits duck/v1alpha1 BindingSpec, which currently provides:
* Subject - Subject references the resource(s) whose &ldquo;runtime contract&rdquo;
should be augmented by Binding implementations.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha2.SinkBindingStatus">SinkBindingStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha2.SinkBinding">SinkBinding</a>)
</p>
<p>
<p>SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="configs.internal.knative.dev/v1alpha1">configs.internal.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 is the v1alpha1 version of the API.</p>
</p>
Resource Types:
<ul><li>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagation">ConfigMapPropagation</a>
</li></ul>
<h3 id="configs.internal.knative.dev/v1alpha1.ConfigMapPropagation">ConfigMapPropagation
</h3>
<p>
<p>ConfigMapPropagation is used to propagate configMaps from original namespace to current namespace</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
configs.internal.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>ConfigMapPropagation</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagationSpec">
ConfigMapPropagationSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the ConfigMapPropagation</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>originalNamespace</code></br>
<em>
string
</em>
</td>
<td>
<p>OriginalNamespace is the namespace where the original configMaps are in</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector only selects original configMaps with corresponding labels</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatus">
ConfigMapPropagationStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the EventType.
This data may be out of date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="configs.internal.knative.dev/v1alpha1.ConfigMapPropagationSpec">ConfigMapPropagationSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagation">ConfigMapPropagation</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>originalNamespace</code></br>
<em>
string
</em>
</td>
<td>
<p>OriginalNamespace is the namespace where the original configMaps are in</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector only selects original configMaps with corresponding labels</p>
</td>
</tr>
</tbody>
</table>
<h3 id="configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatus">ConfigMapPropagationStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagation">ConfigMapPropagation</a>)
</p>
<p>
<p>ConfigMapPropagationStatus represents the current state of a ConfigMapPropagation.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>copyConfigmaps</code></br>
<em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatusCopyConfigMap">
[]ConfigMapPropagationStatusCopyConfigMap
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CopyConfigMaps is the status for each copied configmap.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatusCopyConfigMap">ConfigMapPropagationStatusCopyConfigMap
</h3>
<p>
(<em>Appears on:</em>
<a href="#configs.internal.knative.dev/v1alpha1.ConfigMapPropagationStatus">ConfigMapPropagationStatus</a>)
</p>
<p>
<p>ConfigMapPropagationStatusCopyConfigMap represents the status of a copied configmap</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is copy configmap&rsquo;s name</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
string
</em>
</td>
<td>
<p>Source is &ldquo;originalNamespace/originalConfigMapName&rdquo;</p>
</td>
</tr>
<tr>
<td>
<code>operation</code></br>
<em>
string
</em>
</td>
<td>
<p>Operation represents the operation CMP takes for this configmap. The operations are copy|delete|stop</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
string
</em>
</td>
<td>
<p>Ready represents the operation is ready or not</p>
</td>
</tr>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
<p>Reason indicates reasons if the operation is not ready</p>
</td>
</tr>
<tr>
<td>
<code>resourceVersionFromSource</code></br>
<em>
string
</em>
</td>
<td>
<p>ResourceVersion is the resourceVersion of original configmap</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="duck.knative.dev/v1alpha1">duck.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 is the v1alpha1 version of the API.</p>
</p>
Resource Types:
<ul></ul>
<h3 id="duck.knative.dev/v1alpha1.AddressStatus">AddressStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.AddressableType">AddressableType</a>, 
<a href="#messaging.knative.dev/v1alpha1.ChannelStatus">ChannelStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedStatus">ChannelableCombinedStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelStatus">InMemoryChannelStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelStatus">KafkaChannelStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.NatssChannelStatus">NatssChannelStatus</a>)
</p>
<p>
<p>AddressStatus shows how we expect folks to embed Addressable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Addressable">
Addressable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Addressable">Addressable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">AddressStatus</a>, 
<a href="#eventing.knative.dev/v1alpha1.BrokerStatus">BrokerStatus</a>, 
<a href="#serving.knative.dev/v1alpha1.RouteStatusFields">RouteStatusFields</a>)
</p>
<p>
<p>Addressable provides a generic mechanism for a custom resource
definition to indicate a destination for message delivery.</p>
<p>Addressable is the schema for the destination information. This is
typically stored in the object&rsquo;s <code>status</code>, as this information may
be generated by the controller.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Addressable</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Addressable">
Addressable
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>hostname</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.AddressableType">AddressableType
</h3>
<p>
<p>AddressableType is a skeleton type wrapping Addressable in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Addressable ObjectReferences and
access the Addressable data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Binding">Binding
</h3>
<p>
<p>Binding is a duck type that specifies the partial schema to which all
Binding implementations should adhere.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>subject</code></br>
<em>
knative.dev/pkg/tracker.Reference
</em>
</td>
<td>
<p>Subject references the resource(s) whose &ldquo;runtime contract&rdquo; should be
augmented by Binding implementations.</p>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.BindingSpec">BindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.Binding">Binding</a>, 
<a href="#bindings.knative.dev/v1alpha1.GitHubBindingSpec">GitHubBindingSpec</a>, 
<a href="#bindings.knative.dev/v1alpha1.GitLabBindingSpec">GitLabBindingSpec</a>, 
<a href="#bindings.knative.dev/v1alpha1.KafkaBindingSpec">KafkaBindingSpec</a>, 
<a href="#sources.knative.dev/v1alpha2.SinkBindingSpec">SinkBindingSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.SinkBindingSpec">SinkBindingSpec</a>)
</p>
<p>
<p>BindingSpec specifies the spec portion of the Binding partial-schema.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subject</code></br>
<em>
knative.dev/pkg/tracker.Reference
</em>
</td>
<td>
<p>Subject references the resource(s) whose &ldquo;runtime contract&rdquo; should be
augmented by Binding implementations.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Channelable">Channelable
</h3>
<p>
<p>Channelable is a skeleton type wrapping Subscribable and Addressable in the manner we expect resource writers
defining compatible resources to embed it. We will typically use this type to deserialize
Channelable ObjectReferences and access their subscription and address data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.ChannelableSpec">
ChannelableSpec
</a>
</em>
</td>
<td>
<p>Spec is the part where the Channelable fulfills the Subscribable contract.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>SubscribableTypeSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">
SubscribableTypeSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.ChannelableStatus">
ChannelableStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.ChannelableCombined">ChannelableCombined
</h3>
<p>
<p>ChannelableCombined is a skeleton type wrapping Subscribable and Addressable of both
v1alpha1 and v1beta1 duck types. This is not to be used by resource writers and is
only used by Subscription Controller to synthesize patches and read the Status
of the Channelable Resources.
This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedSpec">
ChannelableCombinedSpec
</a>
</em>
</td>
<td>
<p>Spec is the part where the Channelable fulfills the Subscribable contract.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>SubscribableTypeSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">
SubscribableTypeSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeSpec</code> are embedded into this type.)
</p>
<p>SubscribableTypeSpec is for the v1alpha1 spec compatibility.</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">
SubscribableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableSpec</code> are embedded into this type.)
</p>
<p>SubscribableSpec is for the v1beta1 spec compatibility.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedStatus">
ChannelableCombinedStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.ChannelableCombinedSpec">ChannelableCombinedSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombined">ChannelableCombined</a>)
</p>
<p>
<p>ChannelableSpec contains Spec of the Channelable object</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SubscribableTypeSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">
SubscribableTypeSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeSpec</code> are embedded into this type.)
</p>
<p>SubscribableTypeSpec is for the v1alpha1 spec compatibility.</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableSpec</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableSpec">
SubscribableSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableSpec</code> are embedded into this type.)
</p>
<p>SubscribableSpec is for the v1beta1 spec compatibility.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.ChannelableCombinedStatus">ChannelableCombinedStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombined">ChannelableCombined</a>)
</p>
<p>
<p>ChannelableStatus contains the Status of a Channelable object.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the part where the Channelable fulfills the Addressable contract.</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>SubscribableTypeStatus is the v1alpha1 part of the Subscribers status</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableStatus</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscribableStatus">
SubscribableStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableStatus</code> are embedded into this type.)
</p>
<p>SubscribableStatus is the v1beta1 part of the Subscribers status.</p>
</td>
</tr>
<tr>
<td>
<code>errorChannel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ErrorChannel is set by the channel when it supports native error handling via a channel</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.ChannelableSpec">ChannelableSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.Channelable">Channelable</a>)
</p>
<p>
<p>ChannelableSpec contains Spec of the Channelable object</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SubscribableTypeSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">
SubscribableTypeSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>DeliverySpec contains options controlling the event delivery</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.ChannelableStatus">ChannelableStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.Channelable">Channelable</a>)
</p>
<p>
<p>ChannelableStatus contains the Status of a Channelable object.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the part where the Channelable fulfills the Addressable contract.</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
<tr>
<td>
<code>errorChannel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ErrorChannel is set by the channel when it supports native error handling via a channel</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.LegacyTarget">LegacyTarget
</h3>
<p>
<p>LegacyTarget is a skeleton type wrapping LegacyTargetable in the manner we
want to support unless they get migrated into supporting Legacy.
We will typically use this type to deserialize LegacyTargetable
ObjectReferences and access the LegacyTargetable data.  This is not a
real resource.
** Do not use this for any new resources **</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.LegacyTargetable">
LegacyTargetable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.LegacyTargetable">LegacyTargetable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.LegacyTarget">LegacyTarget</a>)
</p>
<p>
<p>LegacyTargetable left around until we migrate to Addressable in the
dependent resources. Addressable has more structure in the way it
defines the fields. LegacyTargetable only assumed a single string
in the Status field and we&rsquo;re moving towards defining proper structs
under Status rather than strings.
This is to support existing resources until they migrate.</p>
<p>Do not use this for anything new, use Addressable</p>
<p>LegacyTargetable is the old schema for the addressable portion
of the payload</p>
<p>For new resources use Addressable.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>domainInternal</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Resource">Resource
</h3>
<p>
<p>Resource is a skeleton type wrapping all Kubernetes resources. It is typically used to watch
arbitrary other resources (such as any Source or Addressable). This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Subscribable">Subscribable
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.ChannelSpec">ChannelSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelSpec">InMemoryChannelSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelSpec">KafkaChannelSpec</a>, 
<a href="#messaging.knative.dev/v1alpha1.NatssChannelSpec">NatssChannelSpec</a>, 
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">SubscribableTypeSpec</a>)
</p>
<p>
<p>Subscribable is the schema for the subscribable portion of the spec
section of the resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribers</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscriberSpec">
[]SubscriberSpec
</a>
</em>
</td>
<td>
<p>This is the list of subscriptions for this subscribable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.SubscribableStatus">SubscribableStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">SubscribableTypeStatus</a>)
</p>
<p>
<p>SubscribableStatus is the schema for the subscribable&rsquo;s status portion of the status
section of the resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribers</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.SubscriberStatus">
[]SubscriberStatus
</a>
</em>
</td>
<td>
<p>This is the list of subscription&rsquo;s statuses for this channel.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.SubscribableType">SubscribableType
</h3>
<p>
<p>SubscribableType is a skeleton type wrapping Subscribable in the manner we expect resource writers
defining compatible resources to embed it. We will typically use this type to deserialize
SubscribableType ObjectReferences and access the Subscription data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeSpec">
SubscribableTypeSpec
</a>
</em>
</td>
<td>
<p>SubscribableTypeSpec is the part where Subscribable object is
configured as to be compatible with Subscribable contract.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>SubscribableTypeStatus is the part where SubscribableStatus object is
configured as to be compatible with Subscribable contract.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.SubscribableTypeSpec">SubscribableTypeSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedSpec">ChannelableCombinedSpec</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableSpec">ChannelableSpec</a>, 
<a href="#duck.knative.dev/v1alpha1.SubscribableType">SubscribableType</a>)
</p>
<p>
<p>SubscribableTypeSpec shows how we expect folks to embed Subscribable in their Spec field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.SubscribableTypeStatus">SubscribableTypeStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.ChannelStatus">ChannelStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableCombinedStatus">ChannelableCombinedStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.ChannelableStatus">ChannelableStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelStatus">InMemoryChannelStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelStatus">KafkaChannelStatus</a>, 
<a href="#messaging.knative.dev/v1alpha1.NatssChannelStatus">NatssChannelStatus</a>, 
<a href="#duck.knative.dev/v1alpha1.SubscribableType">SubscribableType</a>)
</p>
<p>
<p>SubscribableTypeStatus shows how we expect folks to embed Subscribable in their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribableStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableStatus">
SubscribableStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.SubscriberSpec">SubscriberSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">Subscribable</a>)
</p>
<p>
<p>SubscriberSpec defines a single subscriber to a Subscribable.
Ref is a reference to the Subscription this SubscriberSpec was created for
SubscriberURI is the endpoint for the subscriber
ReplyURI is the endpoint for the reply
At least one of SubscriberURI and ReplyURI must be present</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>uid</code></br>
<em>
k8s.io/apimachinery/pkg/types.UID
</em>
</td>
<td>
<em>(Optional)</em>
<p>UID is used to understand the origin of the subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Generation of the origin of the subscriber with uid:UID.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>replyURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>deadLetterSink</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Target">Target
</h3>
<p>
<p>Target is a skeleton type wrapping Targetable in the manner we expect
resource writers defining compatible resources to embed it.  We will
typically use this type to deserialize Targetable ObjectReferences and
access the Targetable data.  This is not a real resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.TargetStatus">
TargetStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.TargetStatus">TargetStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.Target">Target</a>)
</p>
<p>
<p>TargetStatus shows how we expect folks to embed Targetable in
their Status field.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>targetable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Targetable">
Targetable
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="duck.knative.dev/v1alpha1.Targetable">Targetable
</h3>
<p>
(<em>Appears on:</em>
<a href="#duck.knative.dev/v1alpha1.TargetStatus">TargetStatus</a>)
</p>
<p>
<p>Targetable is an earlier version of the Callable interface.
Callable is a higher-level interface which implements Addressable
but further promises that the destination may synchronously return
response messages in reply to a message.</p>
<p>Targetable implementations should instead implement Addressable and
include an <code>eventing.knative.dev/returns=any</code> annotation.</p>
<p>Targetable is retired; implement Addressable for now.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>domainInternal</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="eventing.knative.dev/v1beta1">eventing.knative.dev/v1beta1</h2>
<p>
<p>Package v1beta1 is the v1beta1 version of the API.</p>
</p>
Resource Types:
<ul><li>
<a href="#eventing.knative.dev/v1beta1.Broker">Broker</a>
</li><li>
<a href="#eventing.knative.dev/v1beta1.EventType">EventType</a>
</li><li>
<a href="#eventing.knative.dev/v1beta1.Trigger">Trigger</a>
</li></ul>
<h3 id="eventing.knative.dev/v1beta1.Broker">Broker
</h3>
<p>
<p>Broker collects a pool of events that are consumable using Triggers. Brokers
provide a well-known endpoint for event delivery that senders can use with
minimal knowledge of the event routing strategy. Receivers use Triggers to
request delivery of events from a Broker&rsquo;s pool to a specific URL or
Addressable endpoint.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Broker</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.BrokerSpec">
BrokerSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Broker.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>config</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Config is a KReference to the configuration that specifies
configuration options for this Broker. For example, this could be
a pointer to a ConfigMap.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for Events within the Broker mesh.
This includes things like retries, DLQ, etc.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.BrokerStatus">
BrokerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Broker. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.EventType">EventType
</h3>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>EventType</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.EventTypeSpec">
EventTypeSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the EventType.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
<p>Type represents the CloudEvents type. It is authoritative.</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>Source is a URI, it represents the CloudEvents source.</p>
</td>
</tr>
<tr>
<td>
<code>schema</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schema is a URI, it represents the CloudEvents schemaurl extension attribute.
It may be a JSON schema, a protobuf schema, etc. It is optional.</p>
</td>
</tr>
<tr>
<td>
<code>schemaData</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>SchemaData allows the CloudEvents schema to be stored directly in the
EventType. Content is dependent on the encoding. Optional attribute.
The contents are not validated or manipulated by the system.</p>
</td>
</tr>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO remove <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a>
Broker refers to the Broker that can provide the EventType.</p>
</td>
</tr>
<tr>
<td>
<code>description</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Description is an optional field used to describe the EventType, in any meaningful way.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.EventTypeStatus">
EventTypeStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the EventType.
This data may be out of date.
TODO might be removed <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.Trigger">Trigger
</h3>
<p>
<p>Trigger represents a request to have events delivered to a consumer from a
Broker&rsquo;s event pool.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
eventing.knative.dev/v1beta1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Trigger</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.TriggerSpec">
TriggerSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Trigger.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<p>Broker is the broker that this trigger receives events from. If not specified, will default
to &lsquo;default&rsquo;.</p>
</td>
</tr>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.TriggerFilter">
TriggerFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filter is the filter to apply against all events from the Broker. Only events that pass this
filter will be sent to the Subscriber. If not specified, will default to allowing all events.</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber is the addressable that receives events from the Broker that pass the Filter. It
is required.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.TriggerStatus">
TriggerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Trigger. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.BrokerSpec">BrokerSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.Broker">Broker</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>config</code></br>
<em>
<a href="#duck.knative.dev/v1.KReference">
KReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Config is a KReference to the configuration that specifies
configuration options for this Broker. For example, this could be
a pointer to a ConfigMap.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for Events within the Broker mesh.
This includes things like retries, DLQ, etc.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.BrokerStatus">BrokerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.Broker">Broker</a>)
</p>
<p>
<p>BrokerStatus represents the current state of a Broker.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>address</code></br>
<em>
<a href="#duck.knative.dev/v1.Addressable">
Addressable
</a>
</em>
</td>
<td>
<p>Broker is Addressable. It exposes the endpoint as an URI to get events
delivered into the Broker mesh.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.EventTypeSpec">EventTypeSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.EventType">EventType</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
<p>Type represents the CloudEvents type. It is authoritative.</p>
</td>
</tr>
<tr>
<td>
<code>source</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>Source is a URI, it represents the CloudEvents source.</p>
</td>
</tr>
<tr>
<td>
<code>schema</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<em>(Optional)</em>
<p>Schema is a URI, it represents the CloudEvents schemaurl extension attribute.
It may be a JSON schema, a protobuf schema, etc. It is optional.</p>
</td>
</tr>
<tr>
<td>
<code>schemaData</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>SchemaData allows the CloudEvents schema to be stored directly in the
EventType. Content is dependent on the encoding. Optional attribute.
The contents are not validated or manipulated by the system.</p>
</td>
</tr>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO remove <a href="https://github.com/knative/eventing/issues/2750">https://github.com/knative/eventing/issues/2750</a>
Broker refers to the Broker that can provide the EventType.</p>
</td>
</tr>
<tr>
<td>
<code>description</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Description is an optional field used to describe the EventType, in any meaningful way.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.EventTypeStatus">EventTypeStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.EventType">EventType</a>)
</p>
<p>
<p>EventTypeStatus represents the current state of a EventType.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.TriggerFilter">TriggerFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.TriggerSpec">TriggerSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>attributes</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.TriggerFilterAttributes">
TriggerFilterAttributes
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Attributes filters events by exact match on event context attributes.
Each key in the map is compared with the equivalent key in the event
context. An event passes the filter if all values are equal to the
specified values.</p>
<p>Nested context attributes are not supported as keys. Only string values are supported.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.TriggerFilterAttributes">TriggerFilterAttributes
(<code>map[string]string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.TriggerFilter">TriggerFilter</a>)
</p>
<p>
<p>TriggerFilterAttributes is a map of context attribute names to values for
filtering by equality. Only exact matches will pass the filter. You can use the value &ldquo;
to indicate all strings match.</p>
</p>
<h3 id="eventing.knative.dev/v1beta1.TriggerSpec">TriggerSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.Trigger">Trigger</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>broker</code></br>
<em>
string
</em>
</td>
<td>
<p>Broker is the broker that this trigger receives events from. If not specified, will default
to &lsquo;default&rsquo;.</p>
</td>
</tr>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#eventing.knative.dev/v1beta1.TriggerFilter">
TriggerFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filter is the filter to apply against all events from the Broker. Only events that pass this
filter will be sent to the Subscriber. If not specified, will default to allowing all events.</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber is the addressable that receives events from the Broker that pass the Filter. It
is required.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="eventing.knative.dev/v1beta1.TriggerStatus">TriggerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#eventing.knative.dev/v1beta1.Trigger">Trigger</a>)
</p>
<p>
<p>TriggerStatus represents the current state of a Trigger.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberUri</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>SubscriberURI is the resolved URI of the receiver for this Trigger.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="flows.knative.dev/v1beta1">flows.knative.dev/v1beta1</h2>
<p>
<p>Package v1beta1 is the v1beta1 version of the API.</p>
</p>
Resource Types:
<ul></ul>
<h3 id="flows.knative.dev/v1beta1.Parallel">Parallel
</h3>
<p>
<p>Parallel defines conditional branches that will be wired in
series through Channels and Subscriptions.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelSpec">
ParallelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Parallel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>branches</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelBranch">
[]ParallelBranch
</a>
</em>
</td>
<td>
<p>Branches is the list of Filter/Subscribers pairs.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of a case Subscriber gets sent to
when the case does not have a Reply</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelStatus">
ParallelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Parallel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelBranch">ParallelBranch
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.ParallelSpec">ParallelSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>filter</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filter is the expression guarding the branch</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Subscriber receiving the event when the filter passes</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of Subscriber of this case gets sent to.
If not specified, sent the result to the Parallel Reply</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for events to the subscriber
This includes things like retries, DLQ, etc.
Needed for Roundtripping v1alpha1 &lt;-&gt; v1beta1.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelBranchStatus">ParallelBranchStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.ParallelStatus">ParallelStatus</a>)
</p>
<p>
<p>ParallelBranchStatus represents the current state of a Parallel branch</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>filterSubscriptionStatus</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelSubscriptionStatus">
ParallelSubscriptionStatus
</a>
</em>
</td>
<td>
<p>FilterSubscriptionStatus corresponds to the filter subscription status.</p>
</td>
</tr>
<tr>
<td>
<code>filterChannelStatus</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelChannelStatus">
ParallelChannelStatus
</a>
</em>
</td>
<td>
<p>FilterChannelStatus corresponds to the filter channel status.</p>
</td>
</tr>
<tr>
<td>
<code>subscriberSubscriptionStatus</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelSubscriptionStatus">
ParallelSubscriptionStatus
</a>
</em>
</td>
<td>
<p>SubscriptionStatus corresponds to the subscriber subscription status.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelChannelStatus">ParallelChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.ParallelBranchStatus">ParallelBranchStatus</a>, 
<a href="#flows.knative.dev/v1beta1.ParallelStatus">ParallelStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Channel is the reference to the underlying channel.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Channel is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelSpec">ParallelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.Parallel">Parallel</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>branches</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelBranch">
[]ParallelBranch
</a>
</em>
</td>
<td>
<p>Branches is the list of Filter/Subscribers pairs.</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of a case Subscriber gets sent to
when the case does not have a Reply</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelStatus">ParallelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.Parallel">Parallel</a>)
</p>
<p>
<p>ParallelStatus represents the current state of a Parallel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>ingressChannelStatus</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelChannelStatus">
ParallelChannelStatus
</a>
</em>
</td>
<td>
<p>IngressChannelStatus corresponds to the ingress channel status.</p>
</td>
</tr>
<tr>
<td>
<code>branchStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.ParallelBranchStatus">
[]ParallelBranchStatus
</a>
</em>
</td>
<td>
<p>BranchStatuses is an array of corresponding to branch statuses.
Matches the Spec.Branches array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the starting point to this Parallel. Sending to this
will target the first subscriber.
It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.ParallelSubscriptionStatus">ParallelSubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.ParallelBranchStatus">ParallelBranchStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscription</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Subscription is the reference to the underlying Subscription.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Subscription is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.Sequence">Sequence
</h3>
<p>
<p>Sequence defines a sequence of Subscribers that will be wired in
series through Channels and Subscriptions.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceSpec">
SequenceSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Sequence.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>steps</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceStep">
[]SequenceStep
</a>
</em>
</td>
<td>
<p>Steps is the list of Destinations (processors / functions) that will be called in the order
provided. Each step has its own delivery options</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of the last Subscriber gets sent to.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceStatus">
SequenceStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Sequence. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.SequenceChannelStatus">SequenceChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.SequenceStatus">SequenceStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Channel is the reference to the underlying channel.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Channel is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.SequenceSpec">SequenceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.Sequence">Sequence</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>steps</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceStep">
[]SequenceStep
</a>
</em>
</td>
<td>
<p>Steps is the list of Destinations (processors / functions) that will be called in the order
provided. Each step has its own delivery options</p>
</td>
</tr>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD
for the namespace (or cluster, in case there are no defaults for the namespace).</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply is a Reference to where the result of the last Subscriber gets sent to.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.SequenceStatus">SequenceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.Sequence">Sequence</a>)
</p>
<p>
<p>SequenceStatus represents the current state of a Sequence.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>subscriptionStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceSubscriptionStatus">
[]SequenceSubscriptionStatus
</a>
</em>
</td>
<td>
<p>SubscriptionStatuses is an array of corresponding Subscription statuses.
Matches the Spec.Steps array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>channelStatuses</code></br>
<em>
<a href="#flows.knative.dev/v1beta1.SequenceChannelStatus">
[]SequenceChannelStatus
</a>
</em>
</td>
<td>
<p>ChannelStatuses is an array of corresponding Channel statuses.
Matches the Spec.Steps array in the order.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>AddressStatus is the starting point to this Sequence. Sending to this
will target the first subscriber.
It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.SequenceStep">SequenceStep
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.SequenceSpec">SequenceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Destination</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>
(Members of <code>Destination</code> are embedded into this type.)
</p>
<p>Subscriber receiving the step event</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery is the delivery specification for events to the subscriber
This includes things like retries, DLQ, etc.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="flows.knative.dev/v1beta1.SequenceSubscriptionStatus">SequenceSubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#flows.knative.dev/v1beta1.SequenceStatus">SequenceStatus</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscription</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Subscription is the reference to the underlying Subscription.</p>
</td>
</tr>
<tr>
<td>
<code>ready</code></br>
<em>
knative.dev/pkg/apis.Condition
</em>
</td>
<td>
<p>ReadyCondition indicates whether the Subscription is ready or not.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="camel.apache.org/v1">camel.apache.org/v1</h2>
<p>
<p>Package v1 contains API Schema definitions for the camel v1 API group</p>
</p>
Resource Types:
<ul></ul>
<h3 id="camel.apache.org/v1.Artifact">Artifact
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildStatus">BuildStatus</a>, 
<a href="#camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus</a>)
</p>
<p>
<p>Artifact &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>id</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>location</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>target</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>checksum</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.BaseTask">BaseTask
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuilderTask">BuilderTask</a>, 
<a href="#camel.apache.org/v1.ContainerTask">ContainerTask</a>)
</p>
<p>
<p>BaseTask &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>affinity</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#affinity-v1-core">
Kubernetes core/v1.Affinity
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>volumes</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#volume-v1-core">
[]Kubernetes core/v1.Volume
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>volumeMounts</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#volumemount-v1-core">
[]Kubernetes core/v1.VolumeMount
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Build">Build
</h3>
<p>
<p>Build is the Schema for the builds API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#camel.apache.org/v1.BuildSpec">
BuildSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>tasks</code></br>
<em>
<a href="#camel.apache.org/v1.Task">
[]Task
</a>
</em>
</td>
<td>
<p>INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
Important: Run &ldquo;operator-sdk generate k8s&rdquo; to regenerate code after modifying this file</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#camel.apache.org/v1.BuildStatus">
BuildStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.BuildCondition">BuildCondition
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildStatus">BuildStatus</a>)
</p>
<p>
<p>BuildCondition describes the state of a resource at a certain point.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#camel.apache.org/v1.BuildConditionType">
BuildConditionType
</a>
</em>
</td>
<td>
<p>Type of integration condition.</p>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#conditionstatus-v1-core">
Kubernetes core/v1.ConditionStatus
</a>
</em>
</td>
<td>
<p>Status of the condition, one of True, False, Unknown.</p>
</td>
</tr>
<tr>
<td>
<code>lastUpdateTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>The last time this condition was updated.</p>
</td>
</tr>
<tr>
<td>
<code>lastTransitionTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>Last time the condition transitioned from one status to another.</p>
</td>
</tr>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
<p>The reason for the condition&rsquo;s last transition.</p>
</td>
</tr>
<tr>
<td>
<code>message</code></br>
<em>
string
</em>
</td>
<td>
<p>A human readable message indicating details about the transition.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.BuildConditionType">BuildConditionType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildCondition">BuildCondition</a>)
</p>
<p>
<p>BuildConditionType &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.BuildPhase">BuildPhase
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildStatus">BuildStatus</a>)
</p>
<p>
<p>BuildPhase &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.BuildSpec">BuildSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Build">Build</a>)
</p>
<p>
<p>BuildSpec defines the desired state of Build</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>tasks</code></br>
<em>
<a href="#camel.apache.org/v1.Task">
[]Task
</a>
</em>
</td>
<td>
<p>INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
Important: Run &ldquo;operator-sdk generate k8s&rdquo; to regenerate code after modifying this file</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.BuildStatus">BuildStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Build">Build</a>)
</p>
<p>
<p>BuildStatus defines the observed state of Build</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>phase</code></br>
<em>
<a href="#camel.apache.org/v1.BuildPhase">
BuildPhase
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>digest</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>baseImage</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifacts</code></br>
<em>
<a href="#camel.apache.org/v1.Artifact">
[]Artifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>error</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>failure</code></br>
<em>
<a href="#camel.apache.org/v1.Failure">
Failure
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>startedAt</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>platform</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#camel.apache.org/v1.BuildCondition">
[]BuildCondition
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>duration</code></br>
<em>
string
</em>
</td>
<td>
<p>Change to Duration / ISO 8601 when CRD uses OpenAPI spec v3
<a href="https://github.com/OAI/OpenAPI-Specification/issues/845">https://github.com/OAI/OpenAPI-Specification/issues/845</a></p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.BuilderTask">BuilderTask
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Task">Task</a>)
</p>
<p>
<p>BuilderTask &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>BaseTask</code></br>
<em>
<a href="#camel.apache.org/v1.BaseTask">
BaseTask
</a>
</em>
</td>
<td>
<p>
(Members of <code>BaseTask</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>meta</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>baseImage</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtime</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeSpec">
RuntimeSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>sources</code></br>
<em>
<a href="#camel.apache.org/v1.SourceSpec">
[]SourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#camel.apache.org/v1.ResourceSpec">
[]ResourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>steps</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>maven</code></br>
<em>
<a href="#camel.apache.org/v1.MavenSpec">
MavenSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>buildDir</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>properties</code></br>
<em>
map[string]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>timeout</code></br>
<em>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration">
Kubernetes meta/v1.Duration
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelArtifact">CamelArtifact
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelArtifact">CamelArtifact</a>, 
<a href="#camel.apache.org/v1.CamelCatalogSpec">CamelCatalogSpec</a>)
</p>
<p>
<p>CamelArtifact &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>CamelArtifactDependency</code></br>
<em>
<a href="#camel.apache.org/v1.CamelArtifactDependency">
CamelArtifactDependency
</a>
</em>
</td>
<td>
<p>
(Members of <code>CamelArtifactDependency</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>schemes</code></br>
<em>
<a href="#camel.apache.org/v1.CamelScheme">
[]CamelScheme
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>languages</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dataformats</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
<a href="#camel.apache.org/v1.CamelArtifact">
[]CamelArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>javaTypes</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelArtifactDependency">CamelArtifactDependency
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelArtifact">CamelArtifact</a>)
</p>
<p>
<p>CamelArtifactDependency represent a maven&rsquo;s dependency</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>MavenArtifact</code></br>
<em>
<a href="#camel.apache.org/v1.MavenArtifact">
MavenArtifact
</a>
</em>
</td>
<td>
<p>
(Members of <code>MavenArtifact</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>exclusions</code></br>
<em>
<a href="#camel.apache.org/v1.CamelArtifactExclusion">
[]CamelArtifactExclusion
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelArtifactExclusion">CamelArtifactExclusion
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelArtifactDependency">CamelArtifactDependency</a>)
</p>
<p>
<p>CamelArtifactExclusion &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>groupId</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifactId</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelCatalog">CamelCatalog
</h3>
<p>
<p>CamelCatalog is the Schema for the camelcatalogs API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#camel.apache.org/v1.CamelCatalogStatus">
CamelCatalogStatus
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#camel.apache.org/v1.CamelCatalogSpec">
CamelCatalogSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>runtime</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeSpec">
RuntimeSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifacts</code></br>
<em>
<a href="#camel.apache.org/v1.CamelArtifact">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.CamelArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>loaders</code></br>
<em>
<a href="#camel.apache.org/v1.CamelLoader">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.CamelLoader
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelCatalogSpec">CamelCatalogSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelCatalog">CamelCatalog</a>)
</p>
<p>
<p>CamelCatalogSpec defines the desired state of CamelCatalog</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>runtime</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeSpec">
RuntimeSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifacts</code></br>
<em>
<a href="#camel.apache.org/v1.CamelArtifact">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.CamelArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>loaders</code></br>
<em>
<a href="#camel.apache.org/v1.CamelLoader">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.CamelLoader
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelCatalogStatus">CamelCatalogStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelCatalog">CamelCatalog</a>)
</p>
<p>
<p>CamelCatalogStatus defines the observed state of CamelCatalog</p>
</p>
<h3 id="camel.apache.org/v1.CamelLoader">CamelLoader
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelCatalogSpec">CamelCatalogSpec</a>)
</p>
<p>
<p>CamelLoader &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>MavenArtifact</code></br>
<em>
<a href="#camel.apache.org/v1.MavenArtifact">
MavenArtifact
</a>
</em>
</td>
<td>
<p>
(Members of <code>MavenArtifact</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>languages</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
<a href="#camel.apache.org/v1.MavenArtifact">
[]MavenArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.CamelScheme">CamelScheme
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelArtifact">CamelArtifact</a>)
</p>
<p>
<p>CamelScheme &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>id</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>passive</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>http</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Capability">Capability
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.RuntimeSpec">RuntimeSpec</a>)
</p>
<p>
<p>Capability &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>dependencies</code></br>
<em>
<a href="#camel.apache.org/v1.MavenArtifact">
[]MavenArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
map[string]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Configurable">Configurable
</h3>
<p>
<p>Configurable &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.ConfigurationSpec">ConfigurationSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitSpec">IntegrationKitSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationSpec">IntegrationSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>ConfigurationSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>value</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.ContainerTask">ContainerTask
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.ImageTask">ImageTask</a>)
</p>
<p>
<p>ContainerTask &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>BaseTask</code></br>
<em>
<a href="#camel.apache.org/v1.BaseTask">
BaseTask
</a>
</em>
</td>
<td>
<p>
(Members of <code>BaseTask</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>command</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>args</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>env</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#envvar-v1-core">
[]Kubernetes core/v1.EnvVar
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>workingDir</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>securityContext</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#securitycontext-v1-core">
Kubernetes core/v1.SecurityContext
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.DataSpec">DataSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.ResourceSpec">ResourceSpec</a>, 
<a href="#camel.apache.org/v1.SourceSpec">SourceSpec</a>)
</p>
<p>
<p>DataSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>content</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>contentRef</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>contentKey</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>compression</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Failure">Failure
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildStatus">BuildStatus</a>, 
<a href="#camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>Failure &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>time</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>recovery</code></br>
<em>
<a href="#camel.apache.org/v1.FailureRecovery">
FailureRecovery
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.FailureRecovery">FailureRecovery
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Failure">Failure</a>)
</p>
<p>
<p>FailureRecovery &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>attempt</code></br>
<em>
int
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>attemptMax</code></br>
<em>
int
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>attemptTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.ImageTask">ImageTask
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Task">Task</a>)
</p>
<p>
<p>ImageTask &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>ContainerTask</code></br>
<em>
<a href="#camel.apache.org/v1.ContainerTask">
ContainerTask
</a>
</em>
</td>
<td>
<p>
(Members of <code>ContainerTask</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>builtImage</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Integration">Integration
</h3>
<p>
<p>Integration is the Schema for the integrations API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationSpec">
IntegrationSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>sources</code></br>
<em>
<a href="#camel.apache.org/v1.SourceSpec">
[]SourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#camel.apache.org/v1.ResourceSpec">
[]ResourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>kit</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>repositories</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationStatus">
IntegrationStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationCondition">IntegrationCondition
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>IntegrationCondition describes the state of a resource at a certain point.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationConditionType">
IntegrationConditionType
</a>
</em>
</td>
<td>
<p>Type of integration condition.</p>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#conditionstatus-v1-core">
Kubernetes core/v1.ConditionStatus
</a>
</em>
</td>
<td>
<p>Status of the condition, one of True, False, Unknown.</p>
</td>
</tr>
<tr>
<td>
<code>lastUpdateTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>The last time this condition was updated.</p>
</td>
</tr>
<tr>
<td>
<code>lastTransitionTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>Last time the condition transitioned from one status to another.</p>
</td>
</tr>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
<p>The reason for the condition&rsquo;s last transition.</p>
</td>
</tr>
<tr>
<td>
<code>message</code></br>
<em>
string
</em>
</td>
<td>
<p>A human readable message indicating details about the transition.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationConditionType">IntegrationConditionType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationCondition">IntegrationCondition</a>)
</p>
<p>
<p>IntegrationConditionType &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationKit">IntegrationKit
</h3>
<p>
<p>IntegrationKit is the Schema for the integrationkits API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationKitSpec">
IntegrationKitSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>repositories</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationKitStatus">
IntegrationKitStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationKitCondition">IntegrationKitCondition
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus</a>)
</p>
<p>
<p>IntegrationKitCondition describes the state of a resource at a certain point.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationKitConditionType">
IntegrationKitConditionType
</a>
</em>
</td>
<td>
<p>Type of integration condition.</p>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#conditionstatus-v1-core">
Kubernetes core/v1.ConditionStatus
</a>
</em>
</td>
<td>
<p>Status of the condition, one of True, False, Unknown.</p>
</td>
</tr>
<tr>
<td>
<code>lastUpdateTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>The last time this condition was updated.</p>
</td>
</tr>
<tr>
<td>
<code>lastTransitionTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>Last time the condition transitioned from one status to another.</p>
</td>
</tr>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
<p>The reason for the condition&rsquo;s last transition.</p>
</td>
</tr>
<tr>
<td>
<code>message</code></br>
<em>
string
</em>
</td>
<td>
<p>A human readable message indicating details about the transition.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationKitConditionType">IntegrationKitConditionType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitCondition">IntegrationKitCondition</a>)
</p>
<p>
<p>IntegrationKitConditionType &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationKitPhase">IntegrationKitPhase
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus</a>)
</p>
<p>
<p>IntegrationKitPhase &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationKitSpec">IntegrationKitSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKit">IntegrationKit</a>)
</p>
<p>
<p>IntegrationKitSpec defines the desired state of IntegrationKit</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>repositories</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKit">IntegrationKit</a>)
</p>
<p>
<p>IntegrationKitStatus defines the observed state of IntegrationKit</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>phase</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationKitPhase">
IntegrationKitPhase
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>baseImage</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>digest</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifacts</code></br>
<em>
<a href="#camel.apache.org/v1.Artifact">
[]Artifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>failure</code></br>
<em>
<a href="#camel.apache.org/v1.Failure">
Failure
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeVersion</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeProvider</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeProvider">
RuntimeProvider
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>platform</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationKitCondition">
[]IntegrationKitCondition
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>version</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPhase">IntegrationPhase
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>IntegrationPhase &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatform">IntegrationPlatform
</h3>
<p>
<p>IntegrationPlatform is the Schema for the integrationplatforms API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">
IntegrationPlatformSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>cluster</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformCluster">
IntegrationPlatformCluster
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>build</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">
IntegrationPlatformBuildSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformResourcesSpec">
IntegrationPlatformResourcesSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformStatus">
IntegrationPlatformStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformBuildPublishStrategy">IntegrationPlatformBuildPublishStrategy
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec</a>)
</p>
<p>
<p>IntegrationPlatformBuildPublishStrategy enumerates all implemented publish strategies</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>)
</p>
<p>
<p>IntegrationPlatformBuildSpec contains platform related build information</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>buildStrategy</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildStrategy">
IntegrationPlatformBuildStrategy
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>publishStrategy</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildPublishStrategy">
IntegrationPlatformBuildPublishStrategy
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeVersion</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeProvider</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeProvider">
RuntimeProvider
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>baseImage</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>properties</code></br>
<em>
map[string]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>registry</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformRegistrySpec">
IntegrationPlatformRegistrySpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>timeout</code></br>
<em>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration">
Kubernetes meta/v1.Duration
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>persistentVolumeClaim</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>maven</code></br>
<em>
<a href="#camel.apache.org/v1.MavenSpec">
MavenSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>httpProxySecret</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>kanikoBuildCache</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformBuildStrategy">IntegrationPlatformBuildStrategy
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec</a>)
</p>
<p>
<p>IntegrationPlatformBuildStrategy enumerates all implemented build strategies</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatformCluster">IntegrationPlatformCluster
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>)
</p>
<p>
<p>IntegrationPlatformCluster is the kind of orchestration cluster the platform is installed into</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatformCondition">IntegrationPlatformCondition
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformStatus">IntegrationPlatformStatus</a>)
</p>
<p>
<p>IntegrationPlatformCondition describes the state of a resource at a certain point.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformConditionType">
IntegrationPlatformConditionType
</a>
</em>
</td>
<td>
<p>Type of integration condition.</p>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#conditionstatus-v1-core">
Kubernetes core/v1.ConditionStatus
</a>
</em>
</td>
<td>
<p>Status of the condition, one of True, False, Unknown.</p>
</td>
</tr>
<tr>
<td>
<code>lastUpdateTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>The last time this condition was updated.</p>
</td>
</tr>
<tr>
<td>
<code>lastTransitionTime</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#time-v1-meta">
Kubernetes meta/v1.Time
</a>
</em>
</td>
<td>
<p>Last time the condition transitioned from one status to another.</p>
</td>
</tr>
<tr>
<td>
<code>reason</code></br>
<em>
string
</em>
</td>
<td>
<p>The reason for the condition&rsquo;s last transition.</p>
</td>
</tr>
<tr>
<td>
<code>message</code></br>
<em>
string
</em>
</td>
<td>
<p>A human readable message indicating details about the transition.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformConditionType">IntegrationPlatformConditionType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformCondition">IntegrationPlatformCondition</a>)
</p>
<p>
<p>IntegrationPlatformConditionType &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatformPhase">IntegrationPlatformPhase
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformStatus">IntegrationPlatformStatus</a>)
</p>
<p>
<p>IntegrationPlatformPhase &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.IntegrationPlatformRegistrySpec">IntegrationPlatformRegistrySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec</a>)
</p>
<p>
<p>IntegrationPlatformRegistrySpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>insecure</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>address</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>secret</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>ca</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>organization</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformResourcesSpec">IntegrationPlatformResourcesSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>)
</p>
<p>
<p>IntegrationPlatformResourcesSpec contains platform related resources</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>kits</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatform">IntegrationPlatform</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformStatus">IntegrationPlatformStatus</a>)
</p>
<p>
<p>IntegrationPlatformSpec defines the desired state of IntegrationPlatform</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>cluster</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformCluster">
IntegrationPlatformCluster
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>build</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">
IntegrationPlatformBuildSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformResourcesSpec">
IntegrationPlatformResourcesSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationPlatformStatus">IntegrationPlatformStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationPlatform">IntegrationPlatform</a>)
</p>
<p>
<p>IntegrationPlatformStatus defines the observed state of IntegrationPlatform</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>IntegrationPlatformSpec</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">
IntegrationPlatformSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>IntegrationPlatformSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>phase</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformPhase">
IntegrationPlatformPhase
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPlatformCondition">
[]IntegrationPlatformCondition
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>version</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationSpec">IntegrationSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceOriginSpec">CamelSourceOriginSpec</a>, 
<a href="#camel.apache.org/v1.Integration">Integration</a>)
</p>
<p>
<p>IntegrationSpec defines the desired state of Integration</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>sources</code></br>
<em>
<a href="#camel.apache.org/v1.SourceSpec">
[]SourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#camel.apache.org/v1.ResourceSpec">
[]ResourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>kit</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>traits</code></br>
<em>
<a href="#camel.apache.org/v1.TraitSpec">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.TraitSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>repositories</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.IntegrationStatus">IntegrationStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.Integration">Integration</a>)
</p>
<p>
<p>IntegrationStatus defines the observed state of Integration</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>phase</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationPhase">
IntegrationPhase
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>digest</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>profile</code></br>
<em>
<a href="#camel.apache.org/v1.TraitProfile">
TraitProfile
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>kit</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>platform</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>generatedSources</code></br>
<em>
<a href="#camel.apache.org/v1.SourceSpec">
[]SourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>generatedResources</code></br>
<em>
<a href="#camel.apache.org/v1.ResourceSpec">
[]ResourceSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>failure</code></br>
<em>
<a href="#camel.apache.org/v1.Failure">
Failure
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeVersion</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>runtimeProvider</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeProvider">
RuntimeProvider
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>configuration</code></br>
<em>
<a href="#camel.apache.org/v1.ConfigurationSpec">
[]ConfigurationSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationCondition">
[]IntegrationCondition
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>version</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>replicas</code></br>
<em>
int32
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>capabilities</code></br>
<em>
[]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Language">Language
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.SourceSpec">SourceSpec</a>)
</p>
<p>
<p>Language &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.MavenArtifact">MavenArtifact
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.CamelArtifactDependency">CamelArtifactDependency</a>, 
<a href="#camel.apache.org/v1.CamelLoader">CamelLoader</a>, 
<a href="#camel.apache.org/v1.Capability">Capability</a>, 
<a href="#camel.apache.org/v1.RuntimeSpec">RuntimeSpec</a>)
</p>
<p>
<p>MavenArtifact &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>groupId</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>artifactId</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>version</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.MavenSpec">MavenSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuilderTask">BuilderTask</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec</a>)
</p>
<p>
<p>MavenSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>localRepository</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>settings</code></br>
<em>
<a href="#camel.apache.org/v1.ValueSource">
ValueSource
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>timeout</code></br>
<em>
<a href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration">
Kubernetes meta/v1.Duration
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.PlatformInjectable">PlatformInjectable
</h3>
<p>
<p>PlatformInjectable &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.ResourceCondition">ResourceCondition
</h3>
<p>
<p>ResourceCondition is a common type for all conditions</p>
</p>
<h3 id="camel.apache.org/v1.ResourceSpec">ResourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuilderTask">BuilderTask</a>, 
<a href="#camel.apache.org/v1.IntegrationSpec">IntegrationSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>ResourceSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>DataSpec</code></br>
<em>
<a href="#camel.apache.org/v1.DataSpec">
DataSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#camel.apache.org/v1.ResourceType">
ResourceType
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>mountPath</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.ResourceType">ResourceType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.ResourceSpec">ResourceSpec</a>)
</p>
<p>
<p>ResourceType &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.RuntimeProvider">RuntimeProvider
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitStatus">IntegrationKitStatus</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformBuildSpec">IntegrationPlatformBuildSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>, 
<a href="#camel.apache.org/v1.RuntimeSpec">RuntimeSpec</a>)
</p>
<p>
<p>RuntimeProvider &ndash;</p>
</p>
<h3 id="camel.apache.org/v1.RuntimeSpec">RuntimeSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuilderTask">BuilderTask</a>, 
<a href="#camel.apache.org/v1.CamelCatalogSpec">CamelCatalogSpec</a>)
</p>
<p>
<p>RuntimeSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>version</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>provider</code></br>
<em>
<a href="#camel.apache.org/v1.RuntimeProvider">
RuntimeProvider
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>applicationClass</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>dependencies</code></br>
<em>
<a href="#camel.apache.org/v1.MavenArtifact">
[]MavenArtifact
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
map[string]string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>capabilities</code></br>
<em>
<a href="#camel.apache.org/v1.Capability">
map[string]github.com/apache/camel-k/pkg/apis/camel/v1.Capability
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.SourceSpec">SourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuilderTask">BuilderTask</a>, 
<a href="#camel.apache.org/v1.IntegrationSpec">IntegrationSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>SourceSpec &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>DataSpec</code></br>
<em>
<a href="#camel.apache.org/v1.DataSpec">
DataSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>language</code></br>
<em>
<a href="#camel.apache.org/v1.Language">
Language
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>loader</code></br>
<em>
string
</em>
</td>
<td>
<p>Loader is an optional id of the org.apache.camel.k.RoutesLoader that will
interpret this source at runtime</p>
</td>
</tr>
<tr>
<td>
<code>interceptors</code></br>
<em>
[]string
</em>
</td>
<td>
<p>Interceptors are optional identifiers the org.apache.camel.k.RoutesLoader
uses to pre/post process sources</p>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.Task">Task
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.BuildSpec">BuildSpec</a>)
</p>
<p>
<p>Task &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>builder</code></br>
<em>
<a href="#camel.apache.org/v1.BuilderTask">
BuilderTask
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>image</code></br>
<em>
<a href="#camel.apache.org/v1.ImageTask">
ImageTask
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.TraitProfile">TraitProfile
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitSpec">IntegrationKitSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationSpec">IntegrationSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationStatus">IntegrationStatus</a>)
</p>
<p>
<p>TraitProfile represents lists of traits that are enabled for the specific installation/integration</p>
</p>
<h3 id="camel.apache.org/v1.TraitSpec">TraitSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.IntegrationKitSpec">IntegrationKitSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationPlatformSpec">IntegrationPlatformSpec</a>, 
<a href="#camel.apache.org/v1.IntegrationSpec">IntegrationSpec</a>)
</p>
<p>
<p>A TraitSpec contains the configuration of a trait</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>configuration</code></br>
<em>
map[string]string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="camel.apache.org/v1.ValueSource">ValueSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#camel.apache.org/v1.MavenSpec">MavenSpec</a>)
</p>
<p>
<p>ValueSource &ndash;</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>configMapKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#configmapkeyselector-v1-core">
Kubernetes core/v1.ConfigMapKeySelector
</a>
</em>
</td>
<td>
<p>Selects a key of a ConfigMap.</p>
</td>
</tr>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>Selects a key of a secret.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="sources.knative.dev/v1alpha1">sources.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 contains API Schema definitions for the sources v1alpha1 API group</p>
</p>
Resource Types:
<ul><li>
<a href="#sources.knative.dev/v1alpha1.ApiServerSource">ApiServerSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.AwsSqsSource">AwsSqsSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.CamelSource">CamelSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.CouchDbSource">CouchDbSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.GitHubSource">GitHubSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.GitLabSource">GitLabSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.PingSource">PingSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.PrometheusSource">PrometheusSource</a>
</li><li>
<a href="#sources.knative.dev/v1alpha1.SinkBinding">SinkBinding</a>
</li></ul>
<h3 id="sources.knative.dev/v1alpha1.ApiServerSource">ApiServerSource
</h3>
<p>
<p>ApiServerSource is the Schema for the apiserversources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>ApiServerSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceSpec">
ApiServerSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.ApiServerResource">
[]ApiServerResource
</a>
</em>
</td>
<td>
<p>Resources is the list of resources to watch</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName is the name of the ServiceAccount to use to run this
source.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>owner</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKind">
APIVersionKind
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ResourceOwner is an additional filter to only track resources that are
owned by a specific resource type. If ResourceOwner matches Resources[n]
then Resources[n] is allowed to pass the ResourceOwner filter.</p>
</td>
</tr>
<tr>
<td>
<code>mode</code></br>
<em>
string
</em>
</td>
<td>
<p>Mode is the mode the receive adapter controller runs under: Ref or Resource.
<code>Ref</code> sends only the reference to the resource.
<code>Resource</code> send the full resource.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceStatus">
ApiServerSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.AwsSqsSource">AwsSqsSource
</h3>
<p>
<p>AwsSqsSource is the Schema for the AWS SQS API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>AwsSqsSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.AwsSqsSourceSpec">
AwsSqsSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>queueUrl</code></br>
<em>
string
</em>
</td>
<td>
<p>QueueURL of the SQS queue that we will poll from.</p>
</td>
</tr>
<tr>
<td>
<code>awsCredsSecret</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>AwsCredsSecret is the credential to use to poll the AWS SQS</p>
</td>
</tr>
<tr>
<td>
<code>annotations</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Annotations to add to the pod, mostly used for Kube2IAM role</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to
use as the sink.  This is where events will be received.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to
run the Receive Adapter Deployment.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.AwsSqsSourceStatus">
AwsSqsSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CamelSource">CamelSource
</h3>
<p>
<p>CamelSource is the Schema for the camelsources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>CamelSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceSpec">
CamelSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>source</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceOriginSpec">
CamelSourceOriginSpec
</a>
</em>
</td>
<td>
<p>Source is the reference to the integration flow to run.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceStatus">
CamelSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CouchDbSource">CouchDbSource
</h3>
<p>
<p>CouchDbSource is the Schema for the githubsources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>CouchDbSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSourceSpec">
CouchDbSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the CouchDbSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>credentials</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>CouchDbCredentials is the credential to use to access CouchDb.
Must be a secret. Only Name and Namespace are used.</p>
</td>
</tr>
<tr>
<td>
<code>feed</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.FeedType">
FeedType
</a>
</em>
</td>
<td>
<p>Feed changes how CouchDB sends the response.
More information: <a href="https://docs.couchdb.org/en/stable/api/database/changes.html#changes-feeds">https://docs.couchdb.org/en/stable/api/database/changes.html#changes-feeds</a></p>
</td>
</tr>
<tr>
<td>
<code>database</code></br>
<em>
string
</em>
</td>
<td>
<p>Database is the database to watch for changes</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSourceStatus">
CouchDbSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.GitHubSource">GitHubSource
</h3>
<p>
<p>GitHubSource is the Schema for the githubsources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GitHubSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.GitHubSourceSpec">
GitHubSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the GitHubSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>ownerAndRepository</code></br>
<em>
string
</em>
</td>
<td>
<p>OwnerAndRepository is the GitHub owner/org and repository to
receive events from. The repository may be left off to receive
events from an entire organization.
Examples:
myuser/project
myorganization</p>
</td>
</tr>
<tr>
<td>
<code>eventTypes</code></br>
<em>
[]string
</em>
</td>
<td>
<p>EventType is the type of event to receive from GitHub. These
correspond to the &ldquo;Webhook event name&rdquo; values listed at
<a href="https://developer.github.com/v3/activity/events/types/">https://developer.github.com/v3/activity/events/types/</a> - ie
&ldquo;pull_request&rdquo;</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitHub
access token</p>
</td>
</tr>
<tr>
<td>
<code>secretToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>SecretToken is the Kubernetes secret containing the GitHub
secret token</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain
name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>githubAPIURL</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>API URL if using github enterprise (default <a href="https://api.github.com">https://api.github.com</a>)</p>
</td>
</tr>
<tr>
<td>
<code>secure</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Secure can be set to true to configure the webhook to use https,
or false to use http.  Omitting it relies on the scheme of the
Knative Service created (e.g. if auto-TLS is enabled it should
do the right thing).</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.GitHubSourceStatus">
GitHubSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.GitLabSource">GitLabSource
</h3>
<p>
<p>GitLabSource is the Schema for the gitlabsources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GitLabSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.GitLabSourceSpec">
GitLabSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the GitLabSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>projectUrl</code></br>
<em>
string
</em>
</td>
<td>
<p>ProjectUrl is the url of the GitLab project for which we are interested
to receive events from.
Examples:
<a href="https://gitlab.com/gitlab-org/gitlab-foss">https://gitlab.com/gitlab-org/gitlab-foss</a></p>
</td>
</tr>
<tr>
<td>
<code>eventTypes</code></br>
<em>
[]string
</em>
</td>
<td>
<p>EventType is the type of event to receive from Gitlab. These
correspond to supported events to the add project hook
<a href="https://docs.gitlab.com/ee/api/projects.html#add-project-hook">https://docs.gitlab.com/ee/api/projects.html#add-project-hook</a></p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitLab
access token</p>
</td>
</tr>
<tr>
<td>
<code>secretToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>SecretToken is the Kubernetes secret containing the GitLab
secret token</p>
</td>
</tr>
<tr>
<td>
<code>sslverify</code></br>
<em>
bool
</em>
</td>
<td>
<p>SslVerify if true configure webhook so the ssl verification is done when triggering the hook</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain
name to use as the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.GitLabSourceStatus">
GitLabSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingSource">PingSource
</h3>
<p>
<p>PingSource is the Schema for the PingSources API.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>PingSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingSourceSpec">
PingSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<p>Schedule is the cronjob schedule.</p>
</td>
</tr>
<tr>
<td>
<code>data</code></br>
<em>
string
</em>
</td>
<td>
<p>Data is the data posted to the target function.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a uri to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to run the Receive
Adapter Deployment.
Deprecated: v1beta1 drops this field.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingResourceSpec">
PingResourceSpec
</a>
</em>
</td>
<td>
<p>Resource limits and Request specifications of the Receive Adapter Deployment
Deprecated: v1beta1 drops this field.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingSourceStatus">
PingSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PrometheusSource">PrometheusSource
</h3>
<p>
<p>PrometheusSource is the Schema for the prometheussources API</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>PrometheusSource</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PrometheusSourceSpec">
PrometheusSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the PrometheusSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>serverURL</code></br>
<em>
string
</em>
</td>
<td>
<p>ServerURL is the URL of the Prometheus server</p>
</td>
</tr>
<tr>
<td>
<code>promQL</code></br>
<em>
string
</em>
</td>
<td>
<p>PromQL is the Prometheus query for this source</p>
</td>
</tr>
<tr>
<td>
<code>authTokenFile</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The name of the file containing the authenication token</p>
</td>
</tr>
<tr>
<td>
<code>caCertConfigMap</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The name of the config map containing the CA certificate of the
Prometheus service&rsquo;s signer.</p>
</td>
</tr>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<p>A crontab-formatted schedule for running the PromQL query</p>
</td>
</tr>
<tr>
<td>
<code>step</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Query resolution step width in duration format or float number of seconds.
Prometheus duration strings are of the form [0-9]+[smhdwy].</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a host
name to use as the sink.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PrometheusSourceStatus">
PrometheusSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.SinkBinding">SinkBinding
</h3>
<p>
<p>SinkBinding describes a Binding that is also a Source.
The <code>sink</code> (from the Source duck) is resolved to a URL and
then projected into the <code>subject</code> by augmenting the runtime
contract of the referenced containers to have a <code>K_SINK</code>
environment variable holding the endpoint to which to send
cloud events.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
sources.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>SinkBinding</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SinkBindingSpec">
SinkBindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SinkBindingStatus">
SinkBindingStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.ApiServerResource">ApiServerResource
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSourceSpec">ApiServerSourceSpec</a>)
</p>
<p>
<p>ApiServerResource defines the resource to watch</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
<em>
string
</em>
</td>
<td>
<p>API version of the resource to watch.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind of the resource to watch.
More info: <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds">https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</a></p>
</td>
</tr>
<tr>
<td>
<code>labelSelector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<p>LabelSelector restricts this source to objects with the selected labels
More info: <a href="http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors">http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors</a></p>
</td>
</tr>
<tr>
<td>
<code>controllerSelector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#ownerreference-v1-meta">
Kubernetes meta/v1.OwnerReference
</a>
</em>
</td>
<td>
<p>ControllerSelector restricts this source to objects with a controlling owner reference of the specified kind.
Only apiVersion and kind are used. Both are optional.
Deprecated: Per-resource owner refs will no longer be supported in
v1alpha2, please use Spec.Owner as a GKV.</p>
</td>
</tr>
<tr>
<td>
<code>controller</code></br>
<em>
bool
</em>
</td>
<td>
<p>If true, send an event referencing the object controlling the resource
Deprecated: Per-resource controller flag will no longer be supported in
v1alpha2, please use Spec.Owner as a GKV.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.ApiServerSourceSpec">ApiServerSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSource">ApiServerSource</a>)
</p>
<p>
<p>ApiServerSourceSpec defines the desired state of ApiServerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.ApiServerResource">
[]ApiServerResource
</a>
</em>
</td>
<td>
<p>Resources is the list of resources to watch</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName is the name of the ServiceAccount to use to run this
source.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>owner</code></br>
<em>
<a href="#sources.knative.dev/v1alpha2.APIVersionKind">
APIVersionKind
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ResourceOwner is an additional filter to only track resources that are
owned by a specific resource type. If ResourceOwner matches Resources[n]
then Resources[n] is allowed to pass the ResourceOwner filter.</p>
</td>
</tr>
<tr>
<td>
<code>mode</code></br>
<em>
string
</em>
</td>
<td>
<p>Mode is the mode the receive adapter controller runs under: Ref or Resource.
<code>Ref</code> sends only the reference to the resource.
<code>Resource</code> send the full resource.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.ApiServerSourceStatus">ApiServerSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.ApiServerSource">ApiServerSource</a>)
</p>
<p>
<p>ApiServerSourceStatus defines the observed state of ApiServerSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.AwsSqsSourceSpec">AwsSqsSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.AwsSqsSource">AwsSqsSource</a>)
</p>
<p>
<p>AwsSqsSourceSpec defines the desired state of the source.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>queueUrl</code></br>
<em>
string
</em>
</td>
<td>
<p>QueueURL of the SQS queue that we will poll from.</p>
</td>
</tr>
<tr>
<td>
<code>awsCredsSecret</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>AwsCredsSecret is the credential to use to poll the AWS SQS</p>
</td>
</tr>
<tr>
<td>
<code>annotations</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Annotations to add to the pod, mostly used for Kube2IAM role</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to
use as the sink.  This is where events will be received.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to
run the Receive Adapter Deployment.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.AwsSqsSourceStatus">AwsSqsSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.AwsSqsSource">AwsSqsSource</a>)
</p>
<p>
<p>AwsSqsSourceStatus defines the observed state of the source.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CamelSourceOriginSpec">CamelSourceOriginSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceSpec">CamelSourceSpec</a>)
</p>
<p>
<p>CamelSourceOriginSpec is the integration flow to run</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>integration</code></br>
<em>
<a href="#camel.apache.org/v1.IntegrationSpec">
IntegrationSpec
</a>
</em>
</td>
<td>
<p>Integration is a kind of source that contains a Camel K integration</p>
</td>
</tr>
<tr>
<td>
<code>flow</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.Flow">
Flow
</a>
</em>
</td>
<td>
<p>Flow is a kind of source that contains a single Camel YAML flow route</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CamelSourceSpec">CamelSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CamelSource">CamelSource</a>)
</p>
<p>
<p>CamelSourceSpec defines the desired state of CamelSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>source</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceOriginSpec">
CamelSourceOriginSpec
</a>
</em>
</td>
<td>
<p>Source is the reference to the integration flow to run.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CamelSourceStatus">CamelSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CamelSource">CamelSource</a>)
</p>
<p>
<p>CamelSourceStatus defines the observed state of CamelSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1alpha1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>sinkUri</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>SinkURI is the current active sink URI that has been configured for the CamelSource.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CouchDbSourceSpec">CouchDbSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSource">CouchDbSource</a>)
</p>
<p>
<p>CouchDbSourceSpec defines the desired state of CouchDbSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the CouchDbSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>credentials</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>CouchDbCredentials is the credential to use to access CouchDb.
Must be a secret. Only Name and Namespace are used.</p>
</td>
</tr>
<tr>
<td>
<code>feed</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.FeedType">
FeedType
</a>
</em>
</td>
<td>
<p>Feed changes how CouchDB sends the response.
More information: <a href="https://docs.couchdb.org/en/stable/api/database/changes.html#changes-feeds">https://docs.couchdb.org/en/stable/api/database/changes.html#changes-feeds</a></p>
</td>
</tr>
<tr>
<td>
<code>database</code></br>
<em>
string
</em>
</td>
<td>
<p>Database is the database to watch for changes</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.CouchDbSourceStatus">CouchDbSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSource">CouchDbSource</a>)
</p>
<p>
<p>CouchDbSourceStatus defines the observed state of CouchDbSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.FeedType">FeedType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CouchDbSourceSpec">CouchDbSourceSpec</a>)
</p>
<p>
<p>FeedType is the type of Feed</p>
</p>
<h3 id="sources.knative.dev/v1alpha1.Flow">Flow
(<code>map[string]interface{}</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.CamelSourceOriginSpec">CamelSourceOriginSpec</a>)
</p>
<p>
<p>Flow is an unstructured object representing a Camel Flow in YAML/JSON DSL</p>
</p>
<h3 id="sources.knative.dev/v1alpha1.GitHubSourceSpec">GitHubSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitHubSource">GitHubSource</a>)
</p>
<p>
<p>GitHubSourceSpec defines the desired state of GitHubSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the GitHubSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>ownerAndRepository</code></br>
<em>
string
</em>
</td>
<td>
<p>OwnerAndRepository is the GitHub owner/org and repository to
receive events from. The repository may be left off to receive
events from an entire organization.
Examples:
myuser/project
myorganization</p>
</td>
</tr>
<tr>
<td>
<code>eventTypes</code></br>
<em>
[]string
</em>
</td>
<td>
<p>EventType is the type of event to receive from GitHub. These
correspond to the &ldquo;Webhook event name&rdquo; values listed at
<a href="https://developer.github.com/v3/activity/events/types/">https://developer.github.com/v3/activity/events/types/</a> - ie
&ldquo;pull_request&rdquo;</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitHub
access token</p>
</td>
</tr>
<tr>
<td>
<code>secretToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>SecretToken is the Kubernetes secret containing the GitHub
secret token</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain
name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>githubAPIURL</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>API URL if using github enterprise (default <a href="https://api.github.com">https://api.github.com</a>)</p>
</td>
</tr>
<tr>
<td>
<code>secure</code></br>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Secure can be set to true to configure the webhook to use https,
or false to use http.  Omitting it relies on the scheme of the
Knative Service created (e.g. if auto-TLS is enabled it should
do the right thing).</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.GitHubSourceStatus">GitHubSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitHubSource">GitHubSource</a>)
</p>
<p>
<p>GitHubSourceStatus defines the observed state of GitHubSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
<tr>
<td>
<code>webhookIDKey</code></br>
<em>
string
</em>
</td>
<td>
<p>WebhookIDKey is the ID of the webhook registered with GitHub</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.GitLabSourceSpec">GitLabSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitLabSource">GitLabSource</a>)
</p>
<p>
<p>GitLabSourceSpec defines the desired state of GitLabSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the GitLabSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>projectUrl</code></br>
<em>
string
</em>
</td>
<td>
<p>ProjectUrl is the url of the GitLab project for which we are interested
to receive events from.
Examples:
<a href="https://gitlab.com/gitlab-org/gitlab-foss">https://gitlab.com/gitlab-org/gitlab-foss</a></p>
</td>
</tr>
<tr>
<td>
<code>eventTypes</code></br>
<em>
[]string
</em>
</td>
<td>
<p>EventType is the type of event to receive from Gitlab. These
correspond to supported events to the add project hook
<a href="https://docs.gitlab.com/ee/api/projects.html#add-project-hook">https://docs.gitlab.com/ee/api/projects.html#add-project-hook</a></p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitLab
access token</p>
</td>
</tr>
<tr>
<td>
<code>secretToken</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>SecretToken is the Kubernetes secret containing the GitLab
secret token</p>
</td>
</tr>
<tr>
<td>
<code>sslverify</code></br>
<em>
bool
</em>
</td>
<td>
<p>SslVerify if true configure webhook so the ssl verification is done when triggering the hook</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain
name to use as the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.GitLabSourceStatus">GitLabSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitLabSource">GitLabSource</a>)
</p>
<p>
<p>GitLabSourceStatus defines the observed state of GitLabSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
<tr>
<td>
<code>Id</code></br>
<em>
string
</em>
</td>
<td>
<p>ID of the project hook registered with GitLab</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaLimitsSpec">KafkaLimitsSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.KafkaResourceSpec">KafkaResourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>cpu</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>memory</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaRequestsSpec">KafkaRequestsSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.KafkaResourceSpec">KafkaResourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>cpu</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>memory</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaResourceSpec">KafkaResourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.KafkaSourceSpec">KafkaSourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>requests</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaRequestsSpec">
KafkaRequestsSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>limits</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaLimitsSpec">
KafkaLimitsSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaSource">KafkaSource
</h3>
<p>
<p>KafkaSource is the Schema for the kafkasources API.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaSourceSpec">
KafkaSourceSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>KafkaAuthSpec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaAuthSpec">
KafkaAuthSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>KafkaAuthSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>topics</code></br>
<em>
[]string
</em>
</td>
<td>
<p>Topic topics to consume messages from</p>
</td>
</tr>
<tr>
<td>
<code>consumerGroup</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ConsumerGroupID is the consumer group ID.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to run the Receive
Adapter Deployment.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaResourceSpec">
KafkaResourceSpec
</a>
</em>
</td>
<td>
<p>Resource limits and Request specifications of the Receive Adapter Deployment</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaSourceStatus">
KafkaSourceStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaSourceSpec">KafkaSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.KafkaSource">KafkaSource</a>)
</p>
<p>
<p>KafkaSourceSpec defines the desired state of the KafkaSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>KafkaAuthSpec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaAuthSpec">
KafkaAuthSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>KafkaAuthSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>topics</code></br>
<em>
[]string
</em>
</td>
<td>
<p>Topic topics to consume messages from</p>
</td>
</tr>
<tr>
<td>
<code>consumerGroup</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ConsumerGroupID is the consumer group ID.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a domain name to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to run the Receive
Adapter Deployment.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.KafkaResourceSpec">
KafkaResourceSpec
</a>
</em>
</td>
<td>
<p>Resource limits and Request specifications of the Receive Adapter Deployment</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.KafkaSourceStatus">KafkaSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.KafkaSource">KafkaSource</a>)
</p>
<p>
<p>KafkaSourceStatus defines the observed state of KafkaSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingLimitsSpec">PingLimitsSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PingResourceSpec">PingResourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>cpu</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>memory</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingRequestsSpec">PingRequestsSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PingResourceSpec">PingResourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>cpu</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>memory</code></br>
<em>
string
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingResourceSpec">PingResourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PingSourceSpec">PingSourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>requests</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingRequestsSpec">
PingRequestsSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>limits</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingLimitsSpec">
PingLimitsSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingSourceSpec">PingSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PingSource">PingSource</a>)
</p>
<p>
<p>PingSourceSpec defines the desired state of the PingSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<p>Schedule is the cronjob schedule.</p>
</td>
</tr>
<tr>
<td>
<code>data</code></br>
<em>
string
</em>
</td>
<td>
<p>Data is the data posted to the target function.</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<p>Sink is a reference to an object that will resolve to a uri to use as the sink.</p>
</td>
</tr>
<tr>
<td>
<code>ceOverrides</code></br>
<em>
<a href="#duck.knative.dev/v1.CloudEventOverrides">
CloudEventOverrides
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CloudEventOverrides defines overrides to control the output format and
modifications of the event sent to the sink.</p>
</td>
</tr>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<p>ServiceAccoutName is the name of the ServiceAccount that will be used to run the Receive
Adapter Deployment.
Deprecated: v1beta1 drops this field.</p>
</td>
</tr>
<tr>
<td>
<code>resources</code></br>
<em>
<a href="#sources.knative.dev/v1alpha1.PingResourceSpec">
PingResourceSpec
</a>
</em>
</td>
<td>
<p>Resource limits and Request specifications of the Receive Adapter Deployment
Deprecated: v1beta1 drops this field.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PingSourceStatus">PingSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PingSource">PingSource</a>)
</p>
<p>
<p>PingSourceStatus defines the observed state of PingSource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PrometheusSourceSpec">PrometheusSourceSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PrometheusSource">PrometheusSource</a>)
</p>
<p>
<p>PrometheusSourceSpec defines the desired state of PrometheusSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceAccountName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceAccountName holds the name of the Kubernetes service account
as which the underlying K8s resources should be run. If unspecified
this will default to the &ldquo;default&rdquo; service account for the namespace
in which the PrometheusSource exists.</p>
</td>
</tr>
<tr>
<td>
<code>serverURL</code></br>
<em>
string
</em>
</td>
<td>
<p>ServerURL is the URL of the Prometheus server</p>
</td>
</tr>
<tr>
<td>
<code>promQL</code></br>
<em>
string
</em>
</td>
<td>
<p>PromQL is the Prometheus query for this source</p>
</td>
</tr>
<tr>
<td>
<code>authTokenFile</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The name of the file containing the authenication token</p>
</td>
</tr>
<tr>
<td>
<code>caCertConfigMap</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The name of the config map containing the CA certificate of the
Prometheus service&rsquo;s signer.</p>
</td>
</tr>
<tr>
<td>
<code>schedule</code></br>
<em>
string
</em>
</td>
<td>
<p>A crontab-formatted schedule for running the PromQL query</p>
</td>
</tr>
<tr>
<td>
<code>step</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Query resolution step width in duration format or float number of seconds.
Prometheus duration strings are of the form [0-9]+[smhdwy].</p>
</td>
</tr>
<tr>
<td>
<code>sink</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Sink is a reference to an object that will resolve to a host
name to use as the sink.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.PrometheusSourceStatus">PrometheusSourceStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.PrometheusSource">PrometheusSource</a>)
</p>
<p>
<p>PrometheusSourceStatus defines the observed state of PrometheusSource</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
<p>inherits duck/v1 SourceStatus, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last
processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current
state.
* SinkURI - the current active sink URI that has been configured for the
Source.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.SecretValueFromSource">SecretValueFromSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitHubSourceSpec">GitHubSourceSpec</a>)
</p>
<p>
<p>SecretValueFromSource represents the source of a secret value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>The Secret key to select from.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.SecretValueFromSource">SecretValueFromSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.GitLabSourceSpec">GitLabSourceSpec</a>)
</p>
<p>
<p>SecretValueFromSource represents the source of a secret value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>The Secret key to select from.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.SinkBindingSpec">SinkBindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.SinkBinding">SinkBinding</a>)
</p>
<p>
<p>SinkBindingSpec holds the desired state of the SinkBinding (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceSpec</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceSpec">
SourceSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="sources.knative.dev/v1alpha1.SinkBindingStatus">SinkBindingStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#sources.knative.dev/v1alpha1.SinkBinding">SinkBinding</a>)
</p>
<p>
<p>SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="bindings.knative.dev/v1alpha1">bindings.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 contains API Schema definitions for the sources v1alpha1 API group</p>
</p>
Resource Types:
<ul><li>
<a href="#bindings.knative.dev/v1alpha1.GitHubBinding">GitHubBinding</a>
</li><li>
<a href="#bindings.knative.dev/v1alpha1.GitLabBinding">GitLabBinding</a>
</li></ul>
<h3 id="bindings.knative.dev/v1alpha1.GitHubBinding">GitHubBinding
</h3>
<p>
<p>GitHubBinding describes a Binding that is also a Source.
The <code>sink</code> (from the Source duck) is resolved to a URL and
then projected into the <code>subject</code> by augmenting the runtime
contract of the referenced containers to have a <code>K_SINK</code>
environment variable holding the endpoint to which to send
cloud events.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
bindings.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GitHubBinding</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.GitHubBindingSpec">
GitHubBindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitHub
access token</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.GitHubBindingStatus">
GitHubBindingStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.GitLabBinding">GitLabBinding
</h3>
<p>
<p>GitLabBinding describes a Binding that is also a Source.
The <code>sink</code> (from the Source duck) is resolved to a URL and
then projected into the <code>subject</code> by augmenting the runtime
contract of the referenced containers to have a <code>K_SINK</code>
environment variable holding the endpoint to which to send
cloud events.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
bindings.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GitLabBinding</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.GitLabBindingSpec">
GitLabBindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitLab
access token</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.GitLabBindingStatus">
GitLabBindingStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.GitHubBindingSpec">GitHubBindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitHubBinding">GitHubBinding</a>)
</p>
<p>
<p>GitHubBindingSpec holds the desired state of the GitHubBinding (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitHub
access token</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.GitHubBindingStatus">GitHubBindingStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitHubBinding">GitHubBinding</a>)
</p>
<p>
<p>GitHubBindingStatus communicates the observed state of the GitHubBinding (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.GitLabBindingSpec">GitLabBindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitLabBinding">GitLabBinding</a>)
</p>
<p>
<p>GitLabBindingSpec holds the desired state of the GitLabBinding (from the client).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>accessToken</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<p>AccessToken is the Kubernetes secret containing the GitLab
access token</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.GitLabBindingStatus">GitLabBindingStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitLabBinding">GitLabBinding</a>)
</p>
<p>
<p>GitLabBindingStatus communicates the observed state of the GitLabBinding (from the controller).</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>SourceStatus</code></br>
<em>
<a href="#duck.knative.dev/v1.SourceStatus">
SourceStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SourceStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaAuthSpec">KafkaAuthSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaBindingSpec">KafkaBindingSpec</a>, 
<a href="#sources.knative.dev/v1alpha1.KafkaSourceSpec">KafkaSourceSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>bootstrapServers</code></br>
<em>
[]string
</em>
</td>
<td>
<p>Bootstrap servers are the Kafka servers the consumer will connect to.</p>
</td>
</tr>
<tr>
<td>
<code>net</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaNetSpec">
KafkaNetSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaBinding">KafkaBinding
</h3>
<p>
<p>KafkaBinding is the Schema for the kafkasources API.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaBindingSpec">
KafkaBindingSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>KafkaAuthSpec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaAuthSpec">
KafkaAuthSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>KafkaAuthSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaBindingStatus">
KafkaBindingStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaBindingSpec">KafkaBindingSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaBinding">KafkaBinding</a>)
</p>
<p>
<p>KafkaBindingSpec defines the desired state of the KafkaBinding.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>BindingSpec</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.BindingSpec">
BindingSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>BindingSpec</code> are embedded into this type.)
</p>
</td>
</tr>
<tr>
<td>
<code>KafkaAuthSpec</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaAuthSpec">
KafkaAuthSpec
</a>
</em>
</td>
<td>
<p>
(Members of <code>KafkaAuthSpec</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaBindingStatus">KafkaBindingStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaBinding">KafkaBinding</a>)
</p>
<p>
<p>KafkaBindingStatus defines the observed state of KafkaBinding.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaNetSpec">KafkaNetSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaAuthSpec">KafkaAuthSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>sasl</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaSASLSpec">
KafkaSASLSpec
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.KafkaTLSSpec">
KafkaTLSSpec
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaSASLSpec">KafkaSASLSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaNetSpec">KafkaNetSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>enable</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>user</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>User is the Kubernetes secret containing the SASL username.</p>
</td>
</tr>
<tr>
<td>
<code>password</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Password is the Kubernetes secret containing the SASL password.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.KafkaTLSSpec">KafkaTLSSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaNetSpec">KafkaNetSpec</a>)
</p>
<p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>enable</code></br>
<em>
bool
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>cert</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Cert is the Kubernetes secret containing the client certificate.</p>
</td>
</tr>
<tr>
<td>
<code>key</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Key is the Kubernetes secret containing the client key.</p>
</td>
</tr>
<tr>
<td>
<code>caCert</code></br>
<em>
<a href="#bindings.knative.dev/v1alpha1.SecretValueFromSource">
SecretValueFromSource
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CACert is the Kubernetes secret containing the server CA cert.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.SecretValueFromSource">SecretValueFromSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.KafkaSASLSpec">KafkaSASLSpec</a>, 
<a href="#bindings.knative.dev/v1alpha1.KafkaTLSSpec">KafkaTLSSpec</a>)
</p>
<p>
<p>SecretValueFromSource represents the source of a secret value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>The Secret key to select from.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.SecretValueFromSource">SecretValueFromSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitLabBindingSpec">GitLabBindingSpec</a>)
</p>
<p>
<p>SecretValueFromSource represents the source of a secret value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>The Secret key to select from.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="bindings.knative.dev/v1alpha1.SecretValueFromSource">SecretValueFromSource
</h3>
<p>
(<em>Appears on:</em>
<a href="#bindings.knative.dev/v1alpha1.GitHubBindingSpec">GitHubBindingSpec</a>)
</p>
<p>
<p>SecretValueFromSource represents the source of a secret value</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>secretKeyRef</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#secretkeyselector-v1-core">
Kubernetes core/v1.SecretKeySelector
</a>
</em>
</td>
<td>
<p>The Secret key to select from.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<h2 id="messaging.knative.dev/v1alpha1">messaging.knative.dev/v1alpha1</h2>
<p>
<p>Package v1alpha1 is the v1alpha1 version of the API.</p>
</p>
Resource Types:
<ul><li>
<a href="#messaging.knative.dev/v1alpha1.Channel">Channel</a>
</li><li>
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannel">InMemoryChannel</a>
</li><li>
<a href="#messaging.knative.dev/v1alpha1.KafkaChannel">KafkaChannel</a>
</li><li>
<a href="#messaging.knative.dev/v1alpha1.NatssChannel">NatssChannel</a>
</li><li>
<a href="#messaging.knative.dev/v1alpha1.Subscription">Subscription</a>
</li></ul>
<h3 id="messaging.knative.dev/v1alpha1.Channel">Channel
</h3>
<p>
<p>Channel represents a generic Channel. It is normally used when we want a Channel, but don&rsquo;t need a specific Channel implementation.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Channel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.ChannelSpec">
ChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<p>ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel.
This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.</p>
</td>
</tr>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>Channel conforms to Duck type Subscribable.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<p>Delivery options.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.ChannelStatus">
ChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Channel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.InMemoryChannel">InMemoryChannel
</h3>
<p>
<p>InMemoryChannel is a resource representing an in memory channel</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>InMemoryChannel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelSpec">
InMemoryChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>Channel conforms to Duck type Subscribable.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<p>For round tripping (v1beta1 &lt;-&gt; v1alpha1&gt;</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannelStatus">
InMemoryChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the Channel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.KafkaChannel">KafkaChannel
</h3>
<p>
<p>KafkaChannel is a resource representing a Kafka Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>KafkaChannel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelSpec">
KafkaChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>numPartitions</code></br>
<em>
int32
</em>
</td>
<td>
<p>NumPartitions is the number of partitions of a Kafka topic. By default, it is set to 1.</p>
</td>
</tr>
<tr>
<td>
<code>replicationFactor</code></br>
<em>
int16
</em>
</td>
<td>
<p>ReplicationFactor is the replication factor of a Kafka topic. By default, it is set to 1.</p>
</td>
</tr>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>KafkaChannel conforms to Duck type Subscribable.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.KafkaChannelStatus">
KafkaChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the KafkaChannel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.NatssChannel">NatssChannel
</h3>
<p>
<p>NatssChannel is a resource representing a NATSS Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>NatssChannel</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
<em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.NatssChannelSpec">
NatssChannelSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of the Channel.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>NatssChannel conforms to Duck type Subscribable.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.NatssChannelStatus">
NatssChannelStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Status represents the current state of the NatssChannel. This data may be out of
date.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.Subscription">Subscription
</h3>
<p>
<p>Subscription routes events received on a Channel to a DNS name and
corresponds to the subscriptions.channels.knative.dev CRD.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
messaging.knative.dev/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Subscription</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.SubscriptionSpec">
SubscriptionSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO By enabling the status subresource metadata.generation should increment
thus making this property obsolete.</p>
<p>We should be able to drop this property with a CRD conversion webhook
in the future</p>
</td>
</tr>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>This field is immutable. We have no good answer on what happens to
the events that are currently in the channel being consumed from
and what the semantics there should be. For now, you can always
delete the Subscription and recreate it to point to a different
channel, giving the user more control over what semantics should
be used (drain the channel first, possibly have events dropped,
etc.)</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Subscriber is reference to (optional) function for processing events.
Events from the Channel will be delivered here and replies are
sent to a Destination as specified by the Reply.</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply specifies (optionally) how to handle events returned from
the Subscriber target.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery configuration</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.SubscriptionStatus">
SubscriptionStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.ChannelSpec">ChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.Channel">Channel</a>)
</p>
<p>
<p>ChannelSpec defines which subscribers have expressed interest in receiving events from this Channel.
It also defines the ChannelTemplate to use in order to create the CRD Channel backing this Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>channelTemplate</code></br>
<em>
<a href="#messaging.knative.dev/v1beta1.ChannelTemplateSpec">
ChannelTemplateSpec
</a>
</em>
</td>
<td>
<p>ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel.
This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.</p>
</td>
</tr>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>Channel conforms to Duck type Subscribable.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<p>Delivery options.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.ChannelStatus">ChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.Channel">Channel</a>)
</p>
<p>
<p>ChannelStatus represents the current state of a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>Channel is Addressable. It currently exposes the endpoint as a
fully-qualified DNS name which will distribute traffic over the
provided targets from inside the cluster.</p>
<p>It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>Channel is an ObjectReference to the Channel CRD backing this Channel.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.InMemoryChannelSpec">InMemoryChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannel">InMemoryChannel</a>)
</p>
<p>
<p>InMemoryChannelSpec defines which subscribers have expressed interest in
receiving events from this InMemoryChannel.
arguments for a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>Channel conforms to Duck type Subscribable.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<p>For round tripping (v1beta1 &lt;-&gt; v1alpha1&gt;</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.InMemoryChannelStatus">InMemoryChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.InMemoryChannel">InMemoryChannel</a>)
</p>
<p>
<p>ChannelStatus represents the current state of a Channel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>InMemoryChannel is Addressable. It currently exposes the endpoint as a
fully-qualified DNS name which will distribute traffic over the
provided targets from inside the cluster.</p>
<p>It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.KafkaChannelSpec">KafkaChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.KafkaChannel">KafkaChannel</a>)
</p>
<p>
<p>KafkaChannelSpec defines the specification for a KafkaChannel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>numPartitions</code></br>
<em>
int32
</em>
</td>
<td>
<p>NumPartitions is the number of partitions of a Kafka topic. By default, it is set to 1.</p>
</td>
</tr>
<tr>
<td>
<code>replicationFactor</code></br>
<em>
int16
</em>
</td>
<td>
<p>ReplicationFactor is the replication factor of a Kafka topic. By default, it is set to 1.</p>
</td>
</tr>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>KafkaChannel conforms to Duck type Subscribable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.KafkaChannelStatus">KafkaChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.KafkaChannel">KafkaChannel</a>)
</p>
<p>
<p>KafkaChannelStatus represents the current state of a KafkaChannel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1beta1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>KafkaChannel is Addressable. It currently exposes the endpoint as a
fully-qualified DNS name which will distribute traffic over the
provided targets from inside the cluster.</p>
<p>It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.NatssChannelSpec">NatssChannelSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.NatssChannel">NatssChannel</a>)
</p>
<p>
<p>NatssChannelSpec defines the specification for a NatssChannel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscribable</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.Subscribable">
Subscribable
</a>
</em>
</td>
<td>
<p>NatssChannel conforms to Duck type Subscribable.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.NatssChannelStatus">NatssChannelStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.NatssChannel">NatssChannel</a>)
</p>
<p>
<p>NatssChannelStatus represents the current state of a NatssChannel.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1beta1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>AddressStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.AddressStatus">
AddressStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>AddressStatus</code> are embedded into this type.)
</p>
<p>NatssChannel is Addressable. It currently exposes the endpoint as a
fully-qualified DNS name which will distribute traffic over the
provided targets from inside the cluster.</p>
<p>It generally has the form {channel}.{namespace}.svc.{cluster domain name}</p>
</td>
</tr>
<tr>
<td>
<code>SubscribableTypeStatus</code></br>
<em>
<a href="#duck.knative.dev/v1alpha1.SubscribableTypeStatus">
SubscribableTypeStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>SubscribableTypeStatus</code> are embedded into this type.)
</p>
<p>Subscribers is populated with the statuses of each of the Channelable&rsquo;s subscribers.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.SubscriptionSpec">SubscriptionSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.Subscription">Subscription</a>)
</p>
<p>
<p>SubscriptionSpec specifies the Channel for incoming events, a Subscriber target
for processing those events and where to put the result of the processing. Only
From (where the events are coming from) is always required. You can optionally
only Process the events (results in no output events) by leaving out the Result.
You can also perform an identity transformation on the incoming events by leaving
out the Subscriber and only specifying Result.</p>
<p>The following are all valid specifications:
channel &ndash;[subscriber]&ndash;&gt; reply
Sink, no outgoing events:
channel &ndash; subscriber
no-op function (identity transformation):
channel &ndash;&gt; reply</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>generation</code></br>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>TODO By enabling the status subresource metadata.generation should increment
thus making this property obsolete.</p>
<p>We should be able to drop this property with a CRD conversion webhook
in the future</p>
</td>
</tr>
<tr>
<td>
<code>channel</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectreference-v1-core">
Kubernetes core/v1.ObjectReference
</a>
</em>
</td>
<td>
<p>This field is immutable. We have no good answer on what happens to
the events that are currently in the channel being consumed from
and what the semantics there should be. For now, you can always
delete the Subscription and recreate it to point to a different
channel, giving the user more control over what semantics should
be used (drain the channel first, possibly have events dropped,
etc.)</p>
</td>
</tr>
<tr>
<td>
<code>subscriber</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Subscriber is reference to (optional) function for processing events.
Events from the Channel will be delivered here and replies are
sent to a Destination as specified by the Reply.</p>
</td>
</tr>
<tr>
<td>
<code>reply</code></br>
<em>
<a href="#duck.knative.dev/v1.Destination">
Destination
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Reply specifies (optionally) how to handle events returned from
the Subscriber target.</p>
</td>
</tr>
<tr>
<td>
<code>delivery</code></br>
<em>
<a href="#duck.knative.dev/v1beta1.DeliverySpec">
DeliverySpec
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Delivery configuration</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.SubscriptionStatus">SubscriptionStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.Subscription">Subscription</a>)
</p>
<p>
<p>SubscriptionStatus (computed) for a subscription</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>Status</code></br>
<em>
<a href="#duck.knative.dev/v1.Status">
Status
</a>
</em>
</td>
<td>
<p>
(Members of <code>Status</code> are embedded into this type.)
</p>
<p>inherits duck/v1 Status, which currently provides:
* ObservedGeneration - the &lsquo;Generation&rsquo; of the Service that was last processed by the controller.
* Conditions - the latest available observations of a resource&rsquo;s current state.</p>
</td>
</tr>
<tr>
<td>
<code>physicalSubscription</code></br>
<em>
<a href="#messaging.knative.dev/v1alpha1.SubscriptionStatusPhysicalSubscription">
SubscriptionStatusPhysicalSubscription
</a>
</em>
</td>
<td>
<p>PhysicalSubscription is the fully resolved values that this Subscription represents.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="messaging.knative.dev/v1alpha1.SubscriptionStatusPhysicalSubscription">SubscriptionStatusPhysicalSubscription
</h3>
<p>
(<em>Appears on:</em>
<a href="#messaging.knative.dev/v1alpha1.SubscriptionStatus">SubscriptionStatus</a>)
</p>
<p>
<p>SubscriptionStatusPhysicalSubscription represents the fully resolved values for this
Subscription.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>subscriberURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>SubscriberURI is the fully resolved URI for spec.subscriber.</p>
</td>
</tr>
<tr>
<td>
<code>replyURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>ReplyURI is the fully resolved URI for the spec.reply.</p>
</td>
</tr>
<tr>
<td>
<code>deadLetterSinkURI</code></br>
<em>
knative.dev/pkg/apis.URL
</em>
</td>
<td>
<p>ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<p><em>
Generated with <code>gen-crd-api-reference-docs</code>
on git commit <code>709e07fc</code>.
</em></p>
