# Deploying to Knative from a Private Github Repo

This sample demonstrates:
* Pulling from a private Github repository using a deploy-key
* Pushing to a private DockerHub repository using a username / password
* Deploying to Knative Serving using image pull secrets

> In this sample, we will assume access to existing Knative Serving service. If not, consult [README.md](https://github.com/knative/serving/blob/master/README.md) on how to deploy one.

## Before you begin

* [Install Knative Serving](https://github.com/knative/docs/blob/master/install/README.md)
* Create a local folder for this sample and download the files in this directory into it.

## Setup

### 1. Setting up the default service account

Knative Serving will run pods as the default service account in the namespace where
you created your resources.  You can see its body by entering the following command:

```shell
$ kubectl get serviceaccount default -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: default
  namespace: default
  ...
secrets:
- name: default-token-zd84v
```

We are going to add to this an image pull Secret.

1. Create your image pull Secret with the following command, replacing values as neccesary:
   ```shell
   kubectl create secret docker-registry dockerhub-pull-secret \
   --docker-server=https://index.docker.io/v1/ --docker-email=not@val.id \
   --docker-username=<your-name> --docker-password=<your-pword>
   ```

   To learn more about Kubernetes pull Secrets, see
   [Creating a Secret in the cluster that holds your authorization token](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-in-the-cluster-that-holds-your-authorization-token).
   
2. Add the newly created `imagePullSecret` to your default service account by entering:
   ```shell
   kubectl edit serviceaccount default
   ```

   This will open the resource in your default text editor. Under `secrets:`, add:

   ```yaml
   secrets:
   - name: default-token-zd84v
   # This is the secret we just created:
   imagePullSecrets:
   - name: dockerhub-pull-secret
   ```


### 2. Configuring the build

The objects in this section are all defined in `build-bot.yaml`, and the fields that
need to be changed say `REPLACE_ME`. Open the `build-bot.yaml` file and make the
necessary replacements.

When finished, set up the build bot by entering the following command:

```shell
kubectl create -f build-bot.yaml
```

The following sections explain the different pieces of the `build-bot.yaml` file.

#### Setting up our Build service account
To separate our Build's credentials from our applications credentials, the
Build runs as its own service account:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: build-bot
secrets:
- name: deploy-key
- name: dockerhub-push-secrets
```

#### Creating a deploy key

You can set up a deploy key for your private Github repository following
[these](https://developer.github.com/v3/guides/managing-deploy-keys/)
instructions.  The deploy key in the `build-bot.yaml` file in this folder is *real*;
you do not need to change it for the sample to work.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: deploy-key
  annotations:
    # This tells us that this credential is for use with
    # github.com repositories.
    build.knative.dev/git-0: github.com
type: kubernetes.io/ssh-auth
data:
  # Generated by:
  # cat id_rsa | base64 -w 1000000
  ssh-privatekey: <long string>

  # Generated by:
  # ssh-keyscan github.com | base64 -w 100000
  known_hosts: <long string>
```

#### Creating a DockerHub push credential

Substitute your DockerHub credentials as instructed in the comments below:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: dockerhub-push-secrets
  annotations:
    build.knative.dev/docker-0: https://index.docker.io/v1/
type: kubernetes.io/basic-auth
data:
  # Generated by:
  # echo -n dockerhub-user | base64
  username: REPLACE_ME
  # Generated by:
  # echo -n dockerhub-password | base64
  password: REPLACE_ME
```

### 3. Installing Build template and updating `manifest.yaml`
1. Apply the [Kaniko build template]
   (https://github.com/knative/build-templates/blob/master/kaniko/kaniko.yaml)
   from the [build-templates](https://github.com/knative/build-templates/) repo.
   Download it, then apply it using the following command:

   ```shell
   kubectl apply -f kaniko.yaml
   ```
   
1. Open `manifest.yaml` and substitute your private DockerHub repository name for
   `REPLACE_ME`.

## Deploying your application

At this point, you're ready to deploy your application:

```shell
kubectl create -f manifest.yaml
```

You can confirm that everything works by capturing the IP of the ingress endpoint:

```
# Put the Host name into an environment variable.
export SERVICE_HOST=`kubectl get route private-repos \
  -o jsonpath="{.status.domain}"`

export SERVICE_IP=`kubectl get svc knative-ingressgateway -n istio-system -o jsonpath="{.status.loadBalancer.ingress[*].ip}"`
```

If your cluster is running outside a cloud provider (for example, on Minikube),
your services will never get an external IP address. In that case, use the Istio
`hostIP` and `nodePort` as the service IP:

```shell
export SERVICE_IP=$(kubectl get po -l knative=ingressgateway -n istio-system -o 'jsonpath={.items[0].status.hostIP}'):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
```

Now curl the service IP to make sure the deployment succeeded:

```
curl -H "Host: $SERVICE_HOST" http://$SERVICE_IP
```


## Appendix: Sample Code

The sample code is in a private Github repository consisting of two files.

1. `Dockerfile`
   ```Dockerfile
   FROM golang

   ENV GOPATH /go

   ADD . /go/src/github.com/dewitt/knative-build

   RUN CGO_ENABLED=0 go build github.com/dewitt/knative-build

   ENTRYPOINT ["knative-build"]
   ```

1. `main.go`

   ```go
   package main

   import (
	   "fmt"
	   "net/http"
   )

   const (
   	   port = ":8080"
   )

   func helloWorld(w http.ResponseWriter, r *http.Request) {
	   fmt.Fprintf(w, "Hello World.")
   }

   func main() {
	   http.HandleFunc("/", helloWorld)
	   http.ListenAndServe(port, nil)
   }
   ```
