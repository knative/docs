# Deploying to Knative from a Private Github Repo

This sample demonstrates:
* Pulling from a private Github repository using a deploy-key
* Pushing to a private DockerHub repository using a username / password
* Deploying to Knative Serving using image pull secrets

> In this sample, we will assume access to existing Knative Serving service. If not, consult [README.md](https://github.com/knative/serving/blob/master/README.md) on how to deploy one.

## Before you begin

* [Install Knative Serving](https://github.com/knative/docs/blob/master/install/README.md)

## Setup

### Setting up the default service account

Knative Serving will run pods as the default service account in the namespace where
you created your resources.  You can see its body by entering the following command:

```shell
$ kubectl get serviceaccount default -o yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: default
  namespace: default
  ...
secrets:
- name: default-token-zd84v
```

We are going to add to this an image pull Secret.

1. Create your image pull Secret with the following command, replacing values as neccesary:
   ```shell
   kubectl create secret docker-registry dockerhub-pull-secret \
   --docker-server=https://index.docker.io/v1/ --docker-email=not@val.id \
   --docker-username=<your-name> --docker-password=<your-pword>
   ```

   To learn more about Kubernetes pull Secrets, see
   [Creating a Secret in the cluster that holds your authorization token]
   (https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-in-the-cluster-that-holds-your-authorization-token).
   
2. Add the newly created `imagePullSecret` to your default service account by entering:
   ```shell
   kubectl edit serviceaccount default
   ```

   This will open the resource in your default text editor. Under `secrets:`, add:

   ```yaml
   secrets:
   - name: default-token-zd84v
   # This is the secret we just created:
   imagePullSecrets:
   - name: dockerhub-pull-secret
   ```


### Setting up our Build service account

To separate our Build's credentials from our applications credentials, we will
have our Build run as its own service account defined via:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: build-bot
secrets:
- name: deploy-key
- name: dockerhub-push-secrets
```

The objects in this section are all defined in `build-bot.yaml`, and the fields that
need to be populated say `REPLACE_ME`.  Once these have been replaced as outlined,
the "build bot" can be set up by entering the following command:

```shell
kubectl create -f build-bot.yaml
```

#### Creating a deploy key

You can set up a deploy key for your private Github repository following
[these](https://developer.github.com/v3/guides/managing-deploy-keys/)
instructions.  The deploy key in the `build-bot.yaml` file in this folder is *real*;
you do not need to change it for the sample to work.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: deploy-key
  annotations:
    # This tells us that this credential is for use with
    # github.com repositories.
    build.knative.dev/git-0: github.com
type: kubernetes.io/ssh-auth
data:
  # Generated by:
  # cat id_rsa | base64 -w 1000000
  ssh-privatekey: <long string>

  # Generated by:
  # ssh-keyscan github.com | base64 -w 100000
  known_hosts: <long string>
```

#### Creating a DockerHub push credential

Substitute your DockerHub credentials as instructed in the comments below:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: dockerhub-push-secrets
  annotations:
    build.knative.dev/docker-0: https://index.docker.io/v1/
type: kubernetes.io/basic-auth
data:
  # Generated by:
  # echo -n dockerhub-user | base64
  username: REPLACE_ME
  # Generated by:
  # echo -n dockerhub-password | base64
  password: REPLACE_ME
```

### 3. Installing Build Templates

This sample uses the [Kaniko build
template](https://github.com/knative/build-templates/blob/master/kaniko/kaniko.yaml)
in the [build-templates](https://github.com/knative/build-templates/) repo.

```shell
kubectl apply -f kaniko.yaml
```

## Deploying

At this point, basically everything has been setup and you simply need to deploy
your application.  There is one remaining substitution to be made in
`manifest.yaml`.  Substitute your private DockerHub repository name for
`REPLACE_ME`.

Then you can run:

```shell
kubectl create -f manifest.yaml
```

As with the other samples, you can confirm that everything works by capturing the IP
of the ingress endpoint:

```
# Put the Host name into an environment variable.
export SERVICE_HOST=`kubectl get route private-repos \
  -o jsonpath="{.status.domain}"`

export SERVICE_IP=`kubectl get svc knative-ingressgateway -n istio-system -o jsonpath="{.status.loadBalancer.ingress[*].ip}"`
```

If your cluster is running outside a cloud provider (for example, on Minikube),
your services will never get an external IP address. In that case, use the Istio `hostIP` and `nodePort` as the service IP:

```shell
export SERVICE_IP=$(kubectl get po -l knative=ingressgateway -n istio-system -o 'jsonpath={.items[0].status.hostIP}'):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
```

Now curl the service IP as if DNS were properly configured:

```
curl -H "Host: $SERVICE_HOST" http://$SERVICE_IP
```


## Appendix: Sample Code

The sample code is in a private Github repository consisting of two files.

1. `Dockerfile`
```Dockerfile
FROM golang

ENV GOPATH /go

ADD . /go/src/github.com/dewitt/knative-build

RUN CGO_ENABLED=0 go build github.com/dewitt/knative-build

ENTRYPOINT ["knative-build"]
```

1. `main.go`

```go
package main

import (
	"fmt"
	"net/http"
)

const (
	port = ":8080"
)

func helloWorld(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello World.")
}

func main() {
	http.HandleFunc("/", helloWorld)
	http.ListenAndServe(port, nil)
}
```
